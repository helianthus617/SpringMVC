<html>
<head>
  <title>AnnotationDrivenBeanDefinitionParser</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="680"/>
<h1>AnnotationDrivenBeanDefinitionParser</h1>

<div>
<span><div>AnnotationDrivenBeanDefinitionParser</div><div>mvc:annotation-driven会自动注册</div><div>RequestMappingHandlerMapping,</div><div>RequestMappingHandlerAdapter，</div><div>ExceptionHandlerExceptionResolver 三个bean</div><div>还提供以下支持</div><div>    支持使用ConversionService 实例对表单参数进行类型转换</div><div>    支持使用@NumberFormat annotation, @DateTimeFormat 注解完成数据类型的格式化</div><div>    支持使用@Valid注解对JavaBean实例进行JSR 303 校验</div><div>    支持使用@RequestBody 和 @ResponseBody</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Override</div><div>     public BeanDefinition parse(Element element, ParserContext  parserContext) {</div><div>           Object source = parserContext.extractSource(element);</div><div>           CompositeComponentDefinition compDefinition = new  CompositeComponentDefinition(element.getTagName(), source);</div><div>           parserContext.pushContainingComponent(compDefinition);</div><div>           RuntimeBeanReference contentNegotiationManager =  getContentNegotiationManager(element, source, parserContext);</div><div>           RootBeanDefinition handlerMappingDef = new  RootBeanDefinition(RequestMappingHandlerMapping.class);</div><div>           handlerMappingDef.setSource(source);</div><div>           handlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div>           handlerMappingDef.getPropertyValues().add(&quot;order&quot;, 0);</div><div>           handlerMappingDef.getPropertyValues().add(&quot;contentNegotiationManager&quot;,  contentNegotiationManager);</div><div>           String methodMappingName =  parserContext.getReaderContext().registerWithGeneratedName(handlerMappingDef);</div><div>           if (element.hasAttribute(&quot;enable-matrix-variables&quot;) ||  element.hasAttribute(&quot;enableMatrixVariables&quot;)) {</div><div>                 Boolean enableMatrixVariables =  Boolean.valueOf(element.getAttribute(</div><div>                             element.hasAttribute(&quot;enable-matrix-variables&quot;) ?  &quot;enable-matrix-variables&quot; : &quot;enableMatrixVariables&quot;));</div><div>                 handlerMappingDef.getPropertyValues().add(&quot;removeSemicolonContent&quot;,  !enableMatrixVariables);</div><div>           }</div><div>           RuntimeBeanReference conversionService =  getConversionService(element, source, parserContext);</div><div>           RuntimeBeanReference validator = getValidator(element,  source, parserContext);</div><div>           RuntimeBeanReference messageCodesResolver =  getMessageCodesResolver(element, source, parserContext);</div><div>           RootBeanDefinition bindingDef = new  RootBeanDefinition(ConfigurableWebBindingInitializer.class);</div><div>           bindingDef.setSource(source);</div><div>           bindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div>           bindingDef.getPropertyValues().add(&quot;conversionService&quot;,  conversionService);</div><div>           bindingDef.getPropertyValues().add(&quot;validator&quot;, validator);</div><div>           bindingDef.getPropertyValues().add(&quot;messageCodesResolver&quot;,  messageCodesResolver);</div><div>           ManagedList&lt;?&gt; messageConverters =  getMessageConverters(element, source, parserContext);</div><div>           ManagedList&lt;?&gt; argumentResolvers =  getArgumentResolvers(element, source, parserContext);</div><div>           ManagedList&lt;?&gt; returnValueHandlers =  getReturnValueHandlers(element, source, parserContext);</div><div>           String asyncTimeout = getAsyncTimeout(element, source,  parserContext);</div><div>           RuntimeBeanReference asyncExecutor =  getAsyncExecutor(element, source, parserContext);</div><div>           ManagedList&lt;?&gt; callableInterceptors =  getCallableInterceptors(element, source, parserContext);</div><div>           ManagedList&lt;?&gt; deferredResultInterceptors =  getDeferredResultInterceptors(element, source, parserContext);</div><div>           RootBeanDefinition handlerAdapterDef = new  RootBeanDefinition(RequestMappingHandlerAdapter.class);</div><div>           handlerAdapterDef.setSource(source);</div><div>           handlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div>           handlerAdapterDef.getPropertyValues().add(&quot;contentNegotiationManager&quot;,  contentNegotiationManager);</div><div>           handlerAdapterDef.getPropertyValues().add(&quot;webBindingInitializer&quot;,  bindingDef);</div><div>           handlerAdapterDef.getPropertyValues().add(&quot;messageConverters&quot;,  messageConverters);</div><div>           if (element.hasAttribute(&quot;ignore-default-model-on-redirect&quot;)  || element.hasAttribute(&quot;ignoreDefaultModelOnRedirect&quot;)) {</div><div>                 Boolean ignoreDefaultModel =  Boolean.valueOf(element.getAttribute(</div><div>                             element.hasAttribute(&quot;ignore-default-model-on-redirect&quot;) ?  &quot;ignore-default-model-on-redirect&quot; : &quot;ignoreDefaultModelOnRedirect&quot;));</div><div>                 handlerAdapterDef.getPropertyValues().add(&quot;ignoreDefaultModelOnRedirect&quot;, ignoreDefaultModel);</div><div>           }</div><div>           if (argumentResolvers != null) {</div><div>                 handlerAdapterDef.getPropertyValues().add(&quot;customArgumentResolvers&quot;,  argumentResolvers);</div><div>           }</div><div>           if (returnValueHandlers != null) {</div><div>                 handlerAdapterDef.getPropertyValues().add(&quot;customReturnValueHandlers&quot;,  returnValueHandlers);</div><div>           }</div><div>           if (asyncTimeout != null) {</div><div>                 handlerAdapterDef.getPropertyValues().add(&quot;asyncRequestTimeout&quot;,  asyncTimeout);</div><div>           }</div><div>           if (asyncExecutor != null) {</div><div>                 handlerAdapterDef.getPropertyValues().add(&quot;taskExecutor&quot;,  asyncExecutor);</div><div>           }</div><div>           handlerAdapterDef.getPropertyValues().add(&quot;callableInterceptors&quot;,  callableInterceptors);</div><div>           handlerAdapterDef.getPropertyValues().add(&quot;deferredResultInterceptors&quot;,  deferredResultInterceptors);</div><div>           String handlerAdapterName =  parserContext.getReaderContext().registerWithGeneratedName(handlerAdapterDef);</div><div>           String uriCompContribName =  MvcUriComponentsBuilder.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME;</div><div>           RootBeanDefinition uriCompContribDef = new  RootBeanDefinition(CompositeUriComponentsContributorFactoryBean.class);</div><div>           uriCompContribDef.setSource(source);</div><div>           uriCompContribDef.getPropertyValues().addPropertyValue(&quot;handlerAdapter&quot;,  handlerAdapterDef);</div><div>           uriCompContribDef.getPropertyValues().addPropertyValue(&quot;conversionService&quot;, conversionService);</div><div>           parserContext.getReaderContext().getRegistry().registerBeanDefinition(uriCompContribName, uriCompContribDef);</div><div>           RootBeanDefinition csInterceptorDef = new  RootBeanDefinition(ConversionServiceExposingInterceptor.class);</div><div>           csInterceptorDef.setSource(source);</div><div>           csInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, conversionService);</div><div>           RootBeanDefinition mappedCsInterceptorDef = new  RootBeanDefinition(MappedInterceptor.class);</div><div>           mappedCsInterceptorDef.setSource(source);</div><div>           mappedCsInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div>           mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, (Object) null);</div><div>           mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, csInterceptorDef);</div><div>           String mappedInterceptorName =  parserContext.getReaderContext().registerWithGeneratedName(mappedCsInterceptorDef);</div><div>           RootBeanDefinition exceptionHandlerExceptionResolver = new  RootBeanDefinition(ExceptionHandlerExceptionResolver.class);</div><div>           exceptionHandlerExceptionResolver.setSource(source);</div><div>           exceptionHandlerExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div>           exceptionHandlerExceptionResolver.getPropertyValues().add(&quot;contentNegotiationManager&quot;, contentNegotiationManager);</div><div>           exceptionHandlerExceptionResolver.getPropertyValues().add(&quot;messageConverters&quot;, messageConverters);</div><div>           exceptionHandlerExceptionResolver.getPropertyValues().add(&quot;order&quot;, 0);</div><div>           String methodExceptionResolverName =</div><div>                       parserContext.getReaderContext().registerWithGeneratedName(exceptionHandlerExceptionResolver);</div><div>           RootBeanDefinition responseStatusExceptionResolver = new  RootBeanDefinition(ResponseStatusExceptionResolver.class);</div><div>           responseStatusExceptionResolver.setSource(source);</div><div>           responseStatusExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div>           responseStatusExceptionResolver.getPropertyValues().add(&quot;order&quot;, 1);</div><div>           String responseStatusExceptionResolverName =</div><div>                       parserContext.getReaderContext().registerWithGeneratedName(responseStatusExceptionResolver);</div><div>           RootBeanDefinition defaultExceptionResolver = new  RootBeanDefinition(DefaultHandlerExceptionResolver.class);</div><div>           defaultExceptionResolver.setSource(source);</div><div>           defaultExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div>           defaultExceptionResolver.getPropertyValues().add(&quot;order&quot;,  2);</div><div>           String defaultExceptionResolverName =</div><div>                       parserContext.getReaderContext().registerWithGeneratedName(defaultExceptionResolver);</div><div>           parserContext.registerComponent(new  BeanComponentDefinition(handlerMappingDef, methodMappingName));</div><div>           parserContext.registerComponent(new  BeanComponentDefinition(handlerAdapterDef, handlerAdapterName));</div><div>           parserContext.registerComponent(new  BeanComponentDefinition(uriCompContribDef, uriCompContribName));</div><div>           parserContext.registerComponent(new  BeanComponentDefinition(exceptionHandlerExceptionResolver,  methodExceptionResolverName));</div><div>           parserContext.registerComponent(new  BeanComponentDefinition(responseStatusExceptionResolver,  responseStatusExceptionResolverName));</div><div>           parserContext.registerComponent(new  BeanComponentDefinition(defaultExceptionResolver,  defaultExceptionResolverName));</div><div>           parserContext.registerComponent(new  BeanComponentDefinition(mappedCsInterceptorDef, mappedInterceptorName));</div><div>           // Ensure BeanNameUrlHandlerMapping (SPR-8289) and default  HandlerAdapters are not &quot;turned off&quot;</div><div>           MvcNamespaceUtils.registerDefaultComponents(parserContext,  source);</div><div>           parserContext.popAndRegisterContainingComponent();</div><div>           return null;</div><div>     }</div></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;">情况1，动态能访问静态不能访问</span></div><div><span style="color: rgb(227, 0, 0); font-weight: bold;"> </span><span style="color: rgb(227, 0, 0); font-weight: bold;"><img src="AnnotationDrivenBeanDefinitionParser_files/Image.png" type="image/png" data-filename="Image.png" width="548"/></span></div><div><span style="font-weight: bold;">handlermapping中无静态资源的映射路径</span></div><div><span style="font-weight: bold; color: rgb(255, 0, 0);">情况2默认交给tomcat处理</span></div><div>&lt;mvc:default-servlet-handler/&gt;</div><div><img src="AnnotationDrivenBeanDefinitionParser_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><img src="AnnotationDrivenBeanDefinitionParser_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold; color: rgb(227, 0, 0);">情况3静态动态都能访问</span></div><div>&lt;mvc:default-servlet-handler/&gt;</div><div>&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;</div><div><img src="AnnotationDrivenBeanDefinitionParser_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><img src="AnnotationDrivenBeanDefinitionParser_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><b><font style="color: rgb(227, 0, 0);">情况4&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 静态不能访问</font></b></div><div><br/></div></span>
</div></body></html> 