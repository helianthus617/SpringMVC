<html>
<head>
  <title>doDisp</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="552"/>
<h1>doDisp</h1>

<div>
<span><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">      protected void doDispatch(HttpServletRequest request,  HttpServletResponse response) throws Exception {</font></div><div><font style="font-size: 12pt;">            HttpServletRequest processedRequest = request;</font></div><div><font style="font-size: 12pt;">            HandlerExecutionChain mappedHandler = null;</font></div><div><font style="font-size: 12pt;">            boolean multipartRequestParsed = false;</font></div><div><font style="font-size: 12pt;">            WebAsyncManager asyncManager =  WebAsyncUtils.getAsyncManager(request);</font></div><div><font style="font-size: 12pt;">            try {</font></div><div><font style="font-size: 12pt;">                  ModelAndView mv = null;</font></div><div><font style="font-size: 12pt;">                  Exception dispatchException = null;</font></div><div><font style="font-size: 12pt;">                  try {</font></div><div><font style="font-size: 12pt;">                        processedRequest = checkMultipart(request);</font></div><div><font style="font-size: 12pt;">                        multipartRequestParsed = processedRequest !=  request;</font></div><div><font style="font-size: 12pt;">                        // Determine handler for the current request.</font></div><div><font style="color: rgb(255, 0, 0); font-size: 12pt;">/<b>/ 根据当前请求找到那个类来处理</b></font></div><div><font style="font-size: 12pt;">                        mappedHandler = getHandler(processedRequest);</font></div><div><font style="font-size: 12pt;">                        if (mappedHandler == null ||  mappedHandler.getHandler() == null) {</font></div><div><font style="font-size: 12pt;">                              noHandlerFound(processedRequest,  response);</font></div><div><font style="font-size: 12pt;">                              return;</font></div><div><font style="font-size: 12pt;">                        }</font></div><div><font style="font-size: 12pt;">                        // Determine handler adapter for the current  request.</font></div><div><font color="#FF4635" style="font-size: 12pt;">//拿到能执行该类方法的适配器 (AnnotationMethodHandlerAdapter相当于反射工具)</font></div><div><font style="font-size: 12pt;">                        HandlerAdapter ha =  getHandlerAdapter(mappedHandler.getHandler());</font></div><div><font style="font-size: 12pt;">                        // Process last-modified header, if supported by  the handler.</font></div><div><font style="font-size: 12pt;">                        String method = request.getMethod();</font></div><div><font style="font-size: 12pt;">                        boolean isGet = &quot;GET&quot;.equals(method);</font></div><div><font style="font-size: 12pt;">                        if (isGet || &quot;HEAD&quot;.equals(method)) {</font></div><div><font style="font-size: 12pt;">                              long lastModified =  ha.getLastModified(request, mappedHandler.getHandler());</font></div><div><font style="font-size: 12pt;">                              if (logger.isDebugEnabled()) {</font></div><div><font style="font-size: 12pt;">                                    String requestUri =  urlPathHelper.getRequestUri(request);</font></div><div><font style="font-size: 12pt;">                                    logger.debug(&quot;Last-Modified value  for [&quot; + requestUri + &quot;] is: &quot; + lastModified);</font></div><div><font style="font-size: 12pt;">                              }</font></div><div><font style="font-size: 12pt;">                              if (new ServletWebRequest(request,  response).checkNotModified(lastModified) &amp;&amp; isGet) {</font></div><div><font style="font-size: 12pt;">                                    return;</font></div><div><font style="font-size: 12pt;">                              }</font></div><div><font style="font-size: 12pt;">                        }</font></div><div><font style="font-size: 12pt;">                        if  (!mappedHandler.applyPreHandle(processedRequest, response)) {</font></div><div><font style="font-size: 12pt;">                              return;</font></div><div><font style="font-size: 12pt;">                        }</font></div><div><font style="font-size: 12pt;">                        try {</font></div><div><span style="color: rgb(255, 0, 0); font-family: Monaco;"><b><font style="font-size: 12pt;">调用方法（适配器来执行目标方法，返回ModelAndView（modelmap+viewname)）</font></b></span></div><div><font style="font-size: 12pt;">                              // Actually invoke the handler.</font></div><div><font style="font-size: 12pt;">                             <font color="#FF0000"><b> mv = ha.handle(</b></font>processedRequest, response,  mappedHandler.getHandler());</font></div><div><font style="font-size: 12pt;">                        }</font></div><div><font style="font-size: 12pt;">                        finally {</font></div><div><font style="font-size: 12pt;">                              if  (asyncManager.isConcurrentHandlingStarted()) {</font></div><div><font style="font-size: 12pt;">                                    return;</font></div><div><font style="font-size: 12pt;">                              }</font></div><div><font style="font-size: 12pt;">                        }</font></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12pt;">如果没有视图名默认设置一个视图名，请求地址名</font></span></div><div><font style="font-size: 12pt;">                        applyDefaultViewName(request, mv);</font></div><div><font style="font-size: 12pt;">                        mappedHandler.applyPostHandle(processedRequest,  response, mv);</font></div><div><font style="font-size: 12pt;">                  }</font></div><div><font style="font-size: 12pt;">                  catch (Exception ex) {</font></div><div><font style="font-size: 12pt;">                        dispatchException = ex;</font></div><div><font style="font-size: 12pt;">                  }</font></div><div><span style="font-family: Monaco;"><font style="color: rgb(255, 0, 0); font-size: 12pt;"><b>转发到目标页面(传入modelandview对象)</b></font></span></div><div><font style="font-size: 12pt;">                  processDispatchResult(processedRequest, response,  mappedHandler, mv, dispatchException);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            catch (Exception ex) {</font></div><div><font style="font-size: 12pt;">                  triggerAfterCompletion(processedRequest, response,  mappedHandler, ex);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            catch (Error err) {</font></div><div><font style="font-size: 12pt;">                  triggerAfterCompletionWithError(processedRequest,  response, mappedHandler, err);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            finally {</font></div><div><font style="font-size: 12pt;">                  if (asyncManager.isConcurrentHandlingStarted()) {</font></div><div><font style="font-size: 12pt;">                        // Instead of postHandle and afterCompletion</font></div><div><font style="font-size: 12pt;">                        mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest,  response);</font></div><div><font style="font-size: 12pt;">                        return;</font></div><div><font style="font-size: 12pt;">                  }</font></div><div><font style="font-size: 12pt;">                  // Clean up any resources used by a multipart request.</font></div><div><font style="font-size: 12pt;">                  if (multipartRequestParsed) {</font></div><div><font style="font-size: 12pt;">                        cleanupMultipart(processedRequest);</font></div><div><font style="font-size: 12pt;">                  }</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">      }</font></div></div><div><span style="font-size: 12pt;">1),所有请求过来DispatcherServlet收到请求,</span></div><div><span style="font-size: 12pt;">2),调用doDispatch()方法进行处理</span></div><div><span style="font-size: 12pt;">    1),getHandler(): 根据当前请求地址找到能处理这个请求的目标处理器类（处理器)</span></div><div><span style="font-size: 12pt;">    2),getHandlerAdapter():根据当前处理器类获取能够执行这个处理器方法的适配器</span></div><div><span style="font-size: 12pt;">    3),使用刚才获取到的适配器（）执行目标方法;</span></div><div><span style="font-size: 12pt;">    4),目标方法执行后会返回一个ModelAndView对象</span></div><div><span style="font-size: 12pt;">    5),根据ModelAndView的信息转发到具体的页面,并可以在请求域中去除Modelandview中的数据模型</span></div><div><span style="font-size: 12pt;">getHandler方法 </span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">protected HandlerExecutionChain getHandler(HttpServletRequest  request) throws Exception {</font></div><div><font style="font-size: 12pt;">for (HandlerMapping hm : this.handlerMappings) {</font></div><div><font color="#FF4635" style="font-size: 12pt;"><b>handlerMappings：保存了每一个处理器能处理哪些请求的映射(DefaultAnnotationHandlerMapping.HandlerMap属性)</b></font></div><div><font style="font-size: 12pt;">         if (logger.isTraceEnabled()) {</font></div><div><font style="font-size: 12pt;">           logger.trace(</font></div><div><font style="font-size: 12pt;">            &quot;Testing handler map [&quot; + hm + &quot;] in  DispatcherServlet with name '&quot; + getServletName() + &quot;'&quot;);</font></div><div><font style="font-size: 12pt;">           }</font></div><div><span style="font-family: Monaco;"><b><font color="#FF4635" style="font-size: 12pt;">拿到某个具体的处理器</font></b></span></div><div><font style="font-size: 12pt;">            HandlerExecutionChain handler =  hm.getHandler(request);</font></div><div><font style="font-size: 12pt;">         if (handler != null) {</font></div><div><font style="font-size: 12pt;">             return handler;</font></div><div><font style="font-size: 12pt;">         }</font></div><div><font style="font-size: 12pt;">     }</font></div><div><font style="font-size: 12pt;">    return null;}</font></div></div><div><span style="font-size: 12pt;">所有的处理器类</span></div><div><span style="font-size: 12pt;"><img src="doDisp_files/Image.png" type="image/png" data-filename="Image.png" width="561"/></span></div><div><span style="font-size: 12pt;">拿到具体的类</span></div><div><span style="font-size: 12pt;"><img src="doDisp_files/Image [1].png" type="image/png" data-filename="Image.png" width="679"/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(235, 0, 115); font-weight: bold;">找到适配器让适配器执行方法</span></font></div><div><span style="font-size: 12pt;">getHandlerAdapter(mappedHandler.getHandler());</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">mappedHandler.getHandler()   com.atguigu.controller.helloworldController@1b5b2c00</font></div><div><font style="font-size: 12pt;">mappedHandler----&gt; HandlerExecutionChain with handler  [com.atguigu.controller.helloworldController@1b5b2c00] and 1 interceptor</font></div><div><br/></div><div><font style="font-size: 12pt;">protected HandlerAdapter getHandlerAdapter(Object handler) throws  ServletException {</font></div><div><font style="font-size: 12pt;">            for (HandlerAdapter ha : this.handlerAdapters) {</font></div><div><font style="font-size: 12pt;">                   if (logger.isTraceEnabled()) {</font></div><div><font style="font-size: 12pt;">                    logger.trace(&quot;Testing handler adapter [&quot; + ha +  &quot;]&quot;);</font></div><div><font style="font-size: 12pt;">                    }</font></div><div><font color="#FF0000" style="font-size: 12pt;">传入helloworldController控制器,该控制器能获得AnnotationMethodHandlerAdapter 适配器</font></div><div><font color="#FF0000" style="font-size: 12pt;">如果helloworldController控制器有方法,if (ha.supports(handler)) 返回true;</font></div><div><font style="font-size: 12pt;">                  if (ha.supports(handler)) {</font></div><div><font style="font-size: 12pt;">            return ha;</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            throw new ServletException(&quot;No adapter for handler [&quot; +  handler +</font></div><div><font style="font-size: 12pt;">      &quot;]: The DispatcherServlet configuration needs to  include a HandlerAdapter that supports this handler&quot;);</font></div><div><font style="font-size: 12pt;">      }</font></div></div><div><span style="font-size: 12pt;">SpringMVC九大组件</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">全部为接口类型:提供了强大的扩展能力</font></div><div><font style="font-size: 12pt;">      private MultipartResolver multipartResolver;</font></div><div><font style="font-size: 12pt;">      private LocaleResolver localeResolver;</font></div><div><font style="font-size: 12pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">           /**主题</span>*/</font></div><div><font style="font-size: 12pt;">      private ThemeResolver themeResolver;</font></div><div><font style="font-size: 12pt;">      private List&lt;HandlerMapping&gt; handlerMappings;</font></div><div><font style="font-size: 12pt;">      /**适配器*/</font></div><div><font style="font-size: 12pt;">      private List&lt;HandlerAdapter&gt; handlerAdapters;</font></div><div><font style="font-size: 12pt;">      /**异常*/</font></div><div><font style="font-size: 12pt;">      private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;</font></div><div><font style="font-size: 12pt;">     </font></div><div><font style="font-size: 12pt;">      private RequestToViewNameTranslator viewNameTranslator;</font></div><div><font style="font-size: 12pt;">      /**FlashMap :springmvc运行重定向携带数据的功能*/</font></div><div><font style="font-size: 12pt;">      private FlashMapManager flashMapManager;</font></div><div><font style="font-size: 12pt;">      private List&lt;ViewResolver&gt; viewResolvers;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">初始化</span>HandlerMapping<span style="color: rgb(51, 51, 51); font-family: Monaco;">启动时运行 ,如果需要修改一些属性的值可以在xml中配置</span></font></div><div><font style="font-size: 12pt;">private void initHandlerMappings(ApplicationContext context) {</font></div><div><font style="font-size: 12pt;">            this.handlerMappings = null;</font></div><div><font style="font-size: 12pt;">//this.detectAllHandlerMappings 默认是true</font></div><div><font style="font-size: 12pt;">            if (this.detectAllHandlerMappings) {</font></div><div><font style="font-size: 12pt;">                  // Find all HandlerMappings in the ApplicationContext,  including ancestor contexts.</font></div><div><font style="font-size: 12pt;">                  Map&lt;String, HandlerMapping&gt; matchingBeans =</font></div><div><font style="font-size: 12pt;">                              BeanFactoryUtils.<b><font color="#EB0073">beansOfTypeIncludingAncestors(context,  HandlerMapping.class, true, false);</font></b></font></div><div><font style="font-size: 12pt;">                  if (!matchingBeans.isEmpty()) {</font></div><div><font style="font-size: 12pt;">                        this.handlerMappings = new  ArrayList&lt;HandlerMapping&gt;(matchingBeans.values());</font></div><div><font style="font-size: 12pt;">                        // We keep HandlerMappings in sorted order.</font></div><div><font style="font-size: 12pt;">                        OrderComparator.sort(this.handlerMappings);</font></div><div><font style="font-size: 12pt;">                  }</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            else {</font></div><div><font style="font-size: 12pt;">                  try {</font></div><div><font style="font-size: 12pt;">                        HandlerMapping hm =  <font color="#EB0073"><b>context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</b></font></font></div><div><font style="font-size: 12pt;">                        this.handlerMappings =  Collections.singletonList(hm);</font></div><div><font style="font-size: 12pt;">                  }</font></div><div><font style="font-size: 12pt;">                  catch (NoSuchBeanDefinitionException ex) {</font></div><div><font style="font-size: 12pt;">                        // Ignore, we'll add a default HandlerMapping  later.</font></div><div><font style="font-size: 12pt;">                  }</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            // Ensure we have at least one HandlerMapping, by  registering</font></div><div><font style="font-size: 12pt;">            // a default HandlerMapping if no other mappings are found.</font></div><div><font style="font-size: 12pt;">            if (this.handlerMappings == null) {</font></div><div><font style="font-size: 12pt;">              <font color="#FF0000"><b>    this.handlerMappings = getDefaultStrategies(context,  HandlerMapping.class);</b></font></font></div><div><font style="font-size: 12pt;">                  if (logger.isDebugEnabled()) {</font></div><div><font style="font-size: 12pt;">                        logger.debug(&quot;No HandlerMappings found in  servlet '&quot; + getServletName() + &quot;': using default&quot;);</font></div><div><font style="font-size: 12pt;">                  }</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">      }</font></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12pt;">组件初始化:</font></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12pt;">    有些组件在容器中是使用类型找的，有些是使用id找的</font></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12pt;">    如果容器中找不到该组件,就使用默认配置</font></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">@SuppressWarnings(&quot;unchecked&quot;)</font></div><div><font style="font-size: 12pt;">     <b><font color="#FF0000"> protected &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext  context, Class&lt;T&gt; strategyInterface) {</font></b></font></div><div><font style="font-size: 12pt;">            String key = strategyInterface.getName();</font></div><div><font style="font-size: 12pt;">       <b><font color="#FF4635">     String value = defaultStrategies.getProperty(key);</font></b></font></div><div><font style="font-size: 12pt;">            if (value != null) {</font></div><div><font style="font-size: 12pt;">                  <b><font color="#EB0073">String[] classNames =  StringUtils.commaDelimitedListToStringArray(value);</font></b></font></div><div><font style="font-size: 12pt;">                  List&lt;T&gt; strategies = new  ArrayList&lt;T&gt;(classNames.length);</font></div><div><font style="font-size: 12pt;">                  for (String className : classNames) {</font></div><div><font style="font-size: 12pt;">                        try {</font></div><div><font style="font-size: 12pt;">                              Class&lt;?&gt; clazz =  ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</font></div><div><font style="font-size: 12pt;">                           <font color="#FF0000"><b>   Object strategy =  createDefaultStrategy(context, clazz);</b></font></font></div><div><font style="font-size: 12pt;">                             <b><font color="#EB0073"> strategies.add((T) strategy);</font></b></font></div><div><font style="font-size: 12pt;">                        }</font></div><div><font style="font-size: 12pt;">                        catch (ClassNotFoundException ex) {</font></div><div><font style="font-size: 12pt;">                              throw new BeanInitializationException(</font></div><div><font style="font-size: 12pt;">                                          &quot;Could not find  DispatcherServlet's default strategy class [&quot; + className +</font></div><div><font style="font-size: 12pt;">                                                      &quot;] for interface  [&quot; + key + &quot;]&quot;, ex);</font></div><div><font style="font-size: 12pt;">                        }</font></div><div><font style="font-size: 12pt;">                        catch (LinkageError err) {</font></div><div><font style="font-size: 12pt;">                              throw new BeanInitializationException(</font></div><div><font style="font-size: 12pt;">                                          &quot;Error loading  DispatcherServlet's default strategy class [&quot; + className +</font></div><div><font style="font-size: 12pt;">                                                      &quot;] for interface  [&quot; + key + &quot;]: problem with class file or dependent class&quot;, err);</font></div><div><font style="font-size: 12pt;">                        }</font></div><div><font style="font-size: 12pt;">                  }</font></div><div><font style="font-size: 12pt;">                  return strategies;</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            else {</font></div><div><font style="font-size: 12pt;">                  return new LinkedList&lt;T&gt;();</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">      }</font></div></div><div><span style="font-size: 12pt;">执行目标方法</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">public <font color="#FF0000"><b>ModelAndView handle(HttpServletRequest request,  HttpServletR</b></font><b><font color="#FF0000">esponse response, Object handler)</font></b></font></div><div><font style="font-size: 12pt;">                  throws Exception {</font></div><div><font style="font-size: 12pt;">            Class&lt;?&gt; clazz = ClassUtils.getUserClass(handler);</font></div><div><font style="font-size: 12pt;">            Boolean annotatedWithSessionAttributes =  this.sessionAnnotatedClassesCache.get(clazz);</font></div><div><font style="font-size: 12pt;">            if (annotatedWithSessionAttributes == null) {</font></div><div><font style="font-size: 12pt;">                  annotatedWithSessionAttributes =  (AnnotationUtils.findAnnotation(clazz, SessionAttributes.class) !=  null);</font></div><div><font style="font-size: 12pt;">                  this.sessionAnnotatedClassesCache.put(clazz,  annotatedWithSessionAttributes);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            if (annotatedWithSessionAttributes) {</font></div><div><font style="font-size: 12pt;">                  // Always prevent caching in case of session attribute  management.</font></div><div><font style="font-size: 12pt;">                  checkAndPrepare(request, response,  this.cacheSecondsForSessionAttributeHandlers, true);</font></div><div><font style="font-size: 12pt;">                  // Prepare cached set of session attributes names.</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            else {</font></div><div><font style="font-size: 12pt;">                  // Uses configured default cacheSeconds setting.</font></div><div><font style="font-size: 12pt;">                  checkAndPrepare(request, response, true);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            // Execute invokeHandlerMethod in synchronized block if  required.</font></div><div><font style="font-size: 12pt;">            if (this.synchronizeOnSession) {</font></div><div><font style="font-size: 12pt;">                  HttpSession session = request.getSession(false);</font></div><div><font style="font-size: 12pt;">                  if (session != null) {</font></div><div><font style="font-size: 12pt;">                        Object mutex =  WebUtils.getSessionMutex(session);</font></div><div><font style="font-size: 12pt;">                        synchronized (mutex) {</font></div><div><font style="font-size: 12pt;">                              return invokeHandlerMethod(request,  response, handler);</font></div><div><font style="font-size: 12pt;">                        }</font></div><div><font style="font-size: 12pt;">                  }</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">          <b><font color="#FF4635">  return invokeHandlerMethod(request, response, handler);</font></b></font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">protected ModelAndView <b><font color="#FF0000">invokeHandlerMethod</font></b>(HttpServletRequest request,  HttpServletResponse response, Object handler)</font></div><div><font style="font-size: 12pt;">                  throws Exception {</font></div><div><font style="font-size: 12pt;">拿到方法解析器</font></div><div><font style="font-size: 12pt;">            ServletHandlerMethodResolver methodResolver =  getMethodResolver(handler);</font></div><div><font style="font-size: 12pt;">            Method handlerMethod =  methodResolver.resolveHandlerMethod(request);</font></div><div><font style="font-size: 12pt;">方法执行器</font></div><div><font style="font-size: 12pt;">            ServletHandlerMethodInvoker methodInvoker = new  ServletHandlerMethodInvoker(methodResolver);</font></div><div><font style="font-size: 12pt;">            ServletWebRequest webRequest = new  ServletWebRequest(request, response);</font></div><div><font style="font-size: 12pt;">创建了</font><font style="font-size: 12pt;">ExtendedModelMap对象</font></div><div><font style="font-size: 12pt;">    <b><font style="color: rgb(255, 70, 53);">        ExtendedModelMap implicitModel = new BindingAwareModelMap();</font></b></font></div><div><font style="font-size: 12pt;"><b><font color="#000000">//真正执行方法的位置</font></b></font></div><div><font style="font-size: 12pt;">            <font color="#FF4635">Object result =  methodInvoker.invokeHandlerMethod(handlerMethod, handler, webRequest,  implicitModel);</font></font></div><div><font style="font-size: 12pt;"><font color="#FF4635"><br/></font></font></div><div><font style="font-size: 12pt;"> </font><font style="font-size: 12pt;">handlerMethod<font> ----&gt; modelattribute0</font></font></div><div><font style="font-size: 12pt;"><font> </font>handler.getClass() </font> <b><font style="font-size: 12pt;">----&gt;</font></b><font><b><font style="font-size: 12pt;"> </font></b><font><b><font style="font-size: 12pt;">C</font></b><span style="font-size: 12pt;">ontrollermodelattribute       </span></font></font></div><div><font style="font-size: 12pt;"> webRequest = new ServletWebRequest(request, response);</font></div><div><br/></div><div><font style="font-size: 12pt;"> ModelAndView mav =</font></div><div><font style="font-size: 12pt;">                    methodInvoker.getModelAndView(handlerMethod,  handler.getClass(), result, implicitModel, webRequest);</font></div><div><font style="font-size: 12pt;">            methodInvoker.updateModelAttributes(handler, (mav != null ?  mav.getModel() : null), implicitModel, webRequest);</font></div><div><font style="font-size: 12pt;">            return mav;</font></div><div><font style="font-size: 12pt;">      }</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>      public final Object <b><font color="#FF4635">invokeHandlerMethod(M</font></b><font color="#FF4635"><b>ethod handlerMethod,  Object handler,</b></font></div><div>                  NativeWebRequest webRequest, ExtendedModelMap  implicitModel) throws Exception {</div><div>            Method handlerMethodToInvoke =  BridgeMethodResolver.findBridgedMethod(handlerMethod);</div><div>            try {</div><div>                  boolean debug = logger.isDebugEnabled();</div><div>                  for (String attrName :  this.methodResolver.getActualSessionAttributeNames()) {</div><div>                        Object attrValue =  this.sessionAttributeStore.retrieveAttribute(webRequest, attrName);</div><div>                        if (attrValue != null) {</div><div>                              implicitModel.addAttribute(attrName,  attrValue);</div><div>                        }</div><div>                  }</div><div>//找到modelAttribute注解标注的方法;</div><div>        <font color="#EB0073"><b>          for (Method attributeMethod :  this.methodResolver.getModelAttributeMethods()) {</b></font></div><div>                        Method <b><font color="#FF4635">attributeMethodToInvoke</font></b> =  BridgeMethodResolver.findBridgedMethod(attributeMethod);</div><div>                        Object[] args =  <b><font color="#FF4635">resolveHandlerArguments</font></b>(<font color="#FF4635"><b>attributeMethodToInvoke</b></font>, handler, webRequest,  implicitModel);</div><div>                        if (debug) {</div><div>                              logger.debug(&quot;Invoking model attribute  method: &quot; + attributeMethodToInvoke);</div><div>                        }</div><div>                        String attrName =  AnnotationUtils.findAnnotation(attributeMethod,  ModelAttribute.class).value();</div><div>                        if (!&quot;&quot;.equals(attrName) &amp;&amp;  implicitModel.containsAttribute(attrName)) {</div><div>                              continue;</div><div>                        }</div><div>                        ReflectionUtils.makeAccessible(attributeMethodToInvoke);</div><div>                     <b><font color="#FF0000">   Object attrValue =  attributeMethodToInvoke.invoke(handler, args);</font></b></div><div>                        if (&quot;&quot;.equals(attrName)) {</div><div>                              Class&lt;?&gt; resolvedType =  GenericTypeResolver.resolveReturnType(attributeMethodToInvoke,  handler.getClass());</div><div>                              attrName =  Conventions.getVariableNameForReturnType(attributeMethodToInvoke,  resolvedType, attrValue);</div><div>                        }</div><div>                        if (!implicitModel.containsAttribute(attrName))  {</div><div>                              <font color="#FF0000"><b>implicitModel.addAttribute(attrName,  attrValue);</b></font></div><div>                        }</div><div>                  }</div><div>              <b><font color="#BC0058">    Object[] args =  resolveHandlerArguments(handlerMethodToInvoke, handler, webRequest,  implicitModel);</font></b></div><div>                  if (debug) {</div><div>                        logger.debug(&quot;Invoking request handler method: &quot;  + handlerMethodToInvoke);</div><div>                  }</div><div>                  ReflectionUtils.makeAccessible(handlerMethodToInvoke);</div><div>                  return handlerMethodToInvoke.invoke(handler, args);</div><div>            }</div><div>            catch (IllegalStateException ex) {</div><div>                  // Internal assertion failed (e.g. invalid signature):</div><div>                  // throw exception with full handler method context...</div><div>                  throw new  HandlerMethodInvocationException(handlerMethodToInvoke, ex);</div><div>            }</div><div>            catch (InvocationTargetException ex) {</div><div>                  // User-defined  @ModelAttribute/@InitBinder/@RequestMapping method threw an exception...</div><div>                  ReflectionUtils.rethrowException(ex.getTargetException());</div><div>                  return null;</div><div>            }</div><div>      }</div><div><br/></div><div><br/></div><div><b><font color="#FF0000">private Object[] resolveHandlerArguments(Method handlerMethod, Object  handler,</font></b></div><div>                  NativeWebRequest webRequest, ExtendedModelMap  implicitModel) throws Exception {</div><div>          <font color="#EB0073">        Class&lt;?&gt;[] paramTypes = handlerMethod.getParameterTypes();</font></div><div>//创建了一个和参数个数一样多的数组,会用来保存每一个参数的值</div><div>            Object[] args = new Object[paramTypes.length];</div><div>            for (int i = 0; i &lt; args.length; i++) {</div><div>                  MethodParameter methodParam = new  MethodParameter(handlerMethod, i);</div><div>                  methodParam.initParameterNameDiscovery(this.parameterNameDiscoverer);</div><div>                  GenericTypeResolver.resolveParameterType(methodParam,  handler.getClass());</div><div>                  String paramName = null;</div><div>                  String headerName = null;</div><div>                  boolean requestBodyFound = false;</div><div>                  String cookieName = null;</div><div>                  String pathVarName = null;</div><div>                  String attrName = null;</div><div>                  boolean required = false;</div><div>                  String defaultValue = null;</div><div>                  boolean validate = false;</div><div>                  Object[] validationHints = null;</div><div>                  int annotationsFound = 0;</div><div>                 <b><font color="#EB0073"> Annotation[] paramAnns =  methodParam.getParameterAnnotations();</font></b></div><div>//如果有注解,就保存注解的所有信息</div><div>                  for (Annotation paramAnn : paramAnns) {</div><div>                        if (RequestParam.class.isInstance(paramAnn)) {</div><div>                              RequestParam requestParam = (RequestParam)  paramAnn;</div><div>                              paramName = requestParam.value();</div><div>                              required = requestParam.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(requestParam.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (RequestHeader.class.isInstance(paramAnn)) {</div><div>                              RequestHeader requestHeader =  (RequestHeader) paramAnn;</div><div>                              headerName = requestHeader.value();</div><div>                              required = requestHeader.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(requestHeader.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (RequestBody.class.isInstance(paramAnn))  {</div><div>                              requestBodyFound = true;</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (CookieValue.class.isInstance(paramAnn))  {</div><div>                              CookieValue cookieValue = (CookieValue)  paramAnn;</div><div>                              cookieName = cookieValue.value();</div><div>                              required = cookieValue.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(cookieValue.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (PathVariable.class.isInstance(paramAnn)) {</div><div>                              PathVariable pathVar = (PathVariable)  paramAnn;</div><div>                              pathVarName = pathVar.value();</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (ModelAttribute.class.isInstance(paramAnn)) {</div><div>                              ModelAttribute attr = (ModelAttribute)  paramAnn;</div><div>                              attrName = attr.value();</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (Value.class.isInstance(paramAnn)) {</div><div>                              defaultValue = ((Value) paramAnn).value();</div><div>                        }</div><div>                        else if  (paramAnn.annotationType().getSimpleName().startsWith(&quot;Valid&quot;)) {</div><div>                              validate = true;</div><div>                              Object value =  AnnotationUtils.getValue(paramAnn);</div><div>                              validationHints = (value instanceof  Object[] ? (Object[]) value : new Object[] {value});</div><div>                        }</div><div>                  }</div><div>                  if (annotationsFound &gt; 1) {</div><div>                        throw new IllegalStateException(&quot;Handler  parameter annotations are exclusive choices - &quot; +</div><div>                                    &quot;do not specify more than one such  annotation on the same parameter: &quot; + handlerMethod);</div><div>                  }</div><div>                 <b><font color="#FF0000"> if (annotationsFound == 0) {</font></b></div><div>                  <font color="#FF4635"><b>      Object argValue =  resolveCommonArgument(methodParam, webRequest);</b></font></div><div>                        if (argValue != WebArgumentResolver.UNRESOLVED)  {</div><div>                              args[i] = argValue;</div><div>                        }</div><div>                        else if (defaultValue != null) {</div><div>                              args[i] =  resolveDefaultValue(defaultValue);</div><div>                        }</div><div>                        else {</div><div>                              Class&lt;?&gt; paramType =  methodParam.getParameterType();</div><div>                              if  (Model.class.isAssignableFrom(paramType) ||  Map.class.isAssignableFrom(paramType)) {</div><div>                                    if  (!paramType.isAssignableFrom(implicitModel.getClass())) {</div><div>                                          throw new  IllegalStateException(&quot;Argument [&quot; + paramType.getSimpleName() + &quot;] is  of type &quot; +</div><div>                                                      &quot;Model or Map but  is not assignable from the actual model. You may need to switch &quot; +</div><div>                                                      &quot;newer MVC  infrastructure classes to use this argument.&quot;);</div><div>                                    }</div><div>                                    args[i] = implicitModel;</div><div>                              }</div><div>                              else if  (SessionStatus.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] = this.sessionStatus;</div><div>                              }</div><div>                              else if  (HttpEntity.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] =  resolveHttpEntityRequest(methodParam, webRequest);</div><div>                              }</div><div>                              else if  (Errors.class.isAssignableFrom(paramType)) {</div><div>                                    throw new  IllegalStateException(&quot;Errors/BindingResult argument declared &quot; +</div><div>                                                &quot;without preceding model  attribute. Check your handler method signature!&quot;);</div><div>                              }</div><div>                              else if  (BeanUtils.isSimpleProperty(paramType)) {</div><div>                                    paramName = &quot;&quot;;</div><div>                              }</div><div>                              else {</div><div>                                    attrName = &quot;&quot;;</div><div>                              }</div><div>                        }</div><div>                  }</div><div>                  if (paramName != null) {</div><div>                        args[i] = resolveRequestParam(paramName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (headerName != null) {</div><div>                        args[i] = resolveRequestHeader(headerName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (requestBodyFound) {</div><div>                        args[i] = resolveRequestBody(methodParam,  webRequest, handler);</div><div>                  }</div><div>                  else if (cookieName != null) {</div><div>                        args[i] = resolveCookieValue(cookieName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (pathVarName != null) {</div><div>                        args[i] = resolvePathVariable(pathVarName,  methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (attrName != null) {</div><div>                        WebDataBinder binder =</div><div>                                    resolveModelAttribute(attrName,  methodParam, implicitModel, webRequest, handler);</div><div>                        boolean assignBindingResult = (args.length &gt; i +  1 &amp;&amp; Errors.class.isAssignableFrom(paramTypes[i + 1]));</div><div>                        if (binder.getTarget() != null) {</div><div>                              doBind(binder, webRequest, validate,  validationHints, !assignBindingResult);</div><div>                        }</div><div>                        args[i] = binder.getTarget();</div><div>                        if (assignBindingResult) {</div><div>                              args[i + 1] = binder.getBindingResult();</div><div>                              i++;</div><div>                        }</div><div>                        implicitModel.putAll(binder.getBindingResult().getModel());</div><div>                  }</div><div>            }</div><div>            return args;</div><div>      }</div><div><br/></div><div><br/></div><div>        --是否是原生API</div><div>  <font color="#FF0000">  <b>  protected Object resolveCommonArgument(MethodParameter  methodParameter, NativeWebRequest webRequest)</b></font></div><div>                  throws Exception {</div><div>            // Invoke custom argument resolvers if present...</div><div>            if (this.customArgumentResolvers != null) {</div><div>                  for (WebArgumentResolver argumentResolver :  this.customArgumentResolvers) {</div><div>                        Object value =  argumentResolver.resolveArgument(methodParameter, webRequest);</div><div>                        if (value != WebArgumentResolver.UNRESOLVED) {</div><div>                              return value;</div><div>                        }</div><div>                  }</div><div>            }</div><div>            // Resolution of standard parameter types...</div><div>            Class&lt;?&gt; paramType = methodParameter.getParameterType();</div><div>        <b><font color="#FF4635">    Object value = resolveStandardArgument(paramType,  webRequest);</font></b></div><div>            if (value != WebArgumentResolver.UNRESOLVED &amp;&amp;  !ClassUtils.isAssignableValue(paramType, value)) {</div><div>                  throw new IllegalStateException(&quot;Standard argument  type [&quot; + paramType.getName() +</div><div>                              &quot;] resolved to incompatible value of type  [&quot; + (value != null ? value.getClass() : null) +</div><div>                              &quot;]. Consider declaring the argument type  in a less specific fashion.&quot;);</div><div>            }</div><div>            return value;</div><div>      }</div><div><br/></div><div><br/></div><div>  --是否是原生API</div><div><font color="#FF0000"><b>protected Object resolveStandardArgument(Class&lt;?&gt; parameterType,  NativeWebRequest webRequest) throws Exception {</b></font></div><div>                  HttpServletRequest request =  webRequest.getNativeRequest(HttpServletRequest.class);</div><div>                  HttpServletResponse response =  webRequest.getNativeResponse(HttpServletResponse.class);</div><div>                  if  (ServletRequest.class.isAssignableFrom(parameterType) ||</div><div>                              MultipartRequest.class.isAssignableFrom(parameterType)) {</div><div>                        Object nativeRequest =  webRequest.getNativeRequest(parameterType);</div><div>                        if (nativeRequest == null) {</div><div>                              throw new IllegalStateException(</div><div>                                          &quot;Current request is not of  type [&quot; + parameterType.getName() + &quot;]: &quot; + request);</div><div>                        }</div><div>                        return nativeRequest;</div><div>                  }</div><div>                  else if  (ServletResponse.class.isAssignableFrom(parameterType)) {</div><div>                        this.responseArgumentUsed = true;</div><div>                        Object nativeResponse =  webRequest.getNativeResponse(parameterType);</div><div>                        if (nativeResponse == null) {</div><div>                              throw new IllegalStateException(</div><div>                                          &quot;Current response is not of  type [&quot; + parameterType.getName() + &quot;]: &quot; + response);</div><div>                        }</div><div>                        return nativeResponse;</div><div>                  }</div><div>                  else if  (HttpSession.class.isAssignableFrom(parameterType)) {</div><div>                        return request.getSession();</div><div>                  }</div><div>                  else if  (Principal.class.isAssignableFrom(parameterType)) {</div><div>                        return request.getUserPrincipal();</div><div>                  }</div><div>                  else if (Locale.class.equals(parameterType)) {</div><div>                        return RequestContextUtils.getLocale(request);</div><div>                  }</div><div>                  else if  (InputStream.class.isAssignableFrom(parameterType)) {</div><div>                        return request.getInputStream();</div><div>                  }</div><div>                  else if (Reader.class.isAssignableFrom(parameterType))  {</div><div>                        return request.getReader();</div><div>                  }</div><div>                  else if  (OutputStream.class.isAssignableFrom(parameterType)) {</div><div>                        this.responseArgumentUsed = true;</div><div>                        return response.getOutputStream();</div><div>                  }</div><div>                  else if (Writer.class.isAssignableFrom(parameterType))  {</div><div>                        this.responseArgumentUsed = true;</div><div>                        return response.getWriter();</div><div>                  }</div><div>                  return super.resolveStandardArgument(parameterType,  webRequest);</div><div>            }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>private Object[] resolveHandlerArguments(Method handlerMethod, Object  handler,</div><div>                  NativeWebRequest webRequest, ExtendedModelMap  implicitModel) throws Exception {</div><div>            Class&lt;?&gt;[] paramTypes = handlerMethod.getParameterTypes();</div><div>            Object[] args = new Object[paramTypes.length];</div><div>            for (int i = 0; i &lt; args.length; i++) {</div><div>                  MethodParameter methodParam = new  MethodParameter(handlerMethod, i);</div><div>                  methodParam.initParameterNameDiscovery(this.parameterNameDiscoverer);</div><div>                  GenericTypeResolver.resolveParameterType(methodParam,  handler.getClass());</div><div>                  String paramName = null;</div><div>                  String headerName = null;</div><div>                  boolean requestBodyFound = false;</div><div>                  String cookieName = null;</div><div>                  String pathVarName = null;</div><div>                  String attrName = null;</div><div>                  boolean required = false;</div><div>                  String defaultValue = null;</div><div>                  boolean validate = false;</div><div>                  Object[] validationHints = null;</div><div>                  int annotationsFound = 0;</div><div>                  Annotation[] paramAnns =  methodParam.getParameterAnnotations();</div><div>                  for (Annotation paramAnn : paramAnns) {</div><div>                        if (RequestParam.class.isInstance(paramAnn)) {</div><div>                              RequestParam requestParam = (RequestParam)  paramAnn;</div><div>                              paramName = requestParam.value();</div><div>                              required = requestParam.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(requestParam.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (RequestHeader.class.isInstance(paramAnn)) {</div><div>                              RequestHeader requestHeader =  (RequestHeader) paramAnn;</div><div>                              headerName = requestHeader.value();</div><div>                              required = requestHeader.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(requestHeader.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (RequestBody.class.isInstance(paramAnn))  {</div><div>                              requestBodyFound = true;</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (CookieValue.class.isInstance(paramAnn))  {</div><div>                              CookieValue cookieValue = (CookieValue)  paramAnn;</div><div>                              cookieName = cookieValue.value();</div><div>                              required = cookieValue.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(cookieValue.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (PathVariable.class.isInstance(paramAnn)) {</div><div>                              PathVariable pathVar = (PathVariable)  paramAnn;</div><div>                              pathVarName = pathVar.value();</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (ModelAttribute.class.isInstance(paramAnn)) {</div><div>                              ModelAttribute attr = (ModelAttribute)  paramAnn;</div><div>                              attrName = attr.value();</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (Value.class.isInstance(paramAnn)) {</div><div>                              defaultValue = ((Value) paramAnn).value();</div><div>                        }</div><div>                        else if  (paramAnn.annotationType().getSimpleName().startsWith(&quot;Valid&quot;)) {</div><div>                              validate = true;</div><div>                              Object value =  AnnotationUtils.getValue(paramAnn);</div><div>                              validationHints = (value instanceof  Object[] ? (Object[]) value : new Object[] {value});</div><div>                        }</div><div>                  }</div><div>                  if (annotationsFound &gt; 1) {</div><div>                        throw new IllegalStateException(&quot;Handler  parameter annotations are exclusive choices - &quot; +</div><div>                                    &quot;do not specify more than one such  annotation on the same parameter: &quot; + handlerMethod);</div><div>                  }</div><div>                  if (annotationsFound == 0) {</div><div>             <b><font color="#FF0000">           Object argValue =  resolveCommonArgument(methodParam, webRequest);</font></b></div><div>                        if (argValue != WebArgumentResolver.UNRESOLVED)  {</div><div>                              args[i] = argValue;</div><div>                        }</div><div>                        else if (defaultValue != null) {</div><div>                              args[i] =  resolveDefaultValue(defaultValue);</div><div>                        }</div><div>                        else {</div><div>                              Class&lt;?&gt; paramType =  methodParam.getParameterType();</div><div>                         <b><font color="#FF0000">     if  (Model.class.isAssignableFrom(paramType) ||  Map.class.isAssignableFrom(paramType)) {</font></b></div><div><b><font color="#FF0000">                                    if  (!paramType.isAssignableFrom(implicitModel.getClass())) {</font></b></div><div><b><font color="#FF0000">                                          throw new  IllegalStateException(&quot;Argument [&quot; + paramType.getSimpleName() + &quot;] is  of type &quot; +</font></b></div><div><b><font color="#FF0000">                                                      &quot;Model or Map but  is not assignable from the actual model. You may need to switch &quot; +</font></b></div><div><b><font color="#FF0000">                                                      &quot;newer MVC  infrastructure classes to use this argument.&quot;);</font></b></div><div><b><font color="#FF0000">                                    }</font></b></div><div><b><font color="#FF0000">                                    args[i] = implicitModel;</font></b></div><div><b><font color="#FF0000">                              }</font></b></div><div>                              else if  (SessionStatus.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] = this.sessionStatus;</div><div>                              }</div><div>                              else if  (HttpEntity.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] =  resolveHttpEntityRequest(methodParam, webRequest);</div><div>                              }</div><div>                              else if  (Errors.class.isAssignableFrom(paramType)) {</div><div>                                    throw new  IllegalStateException(&quot;Errors/BindingResult argument declared &quot; +</div><div>                                                &quot;without preceding model  attribute. Check your handler method signature!&quot;);</div><div>                              }</div><div>                              else if  (BeanUtils.isSimpleProperty(paramType)) {</div><div>                                    paramName = &quot;&quot;;</div><div>                              }</div><div>                              else {</div><div>                                    attrName = &quot;&quot;;</div><div>                              }</div><div>                        }</div><div>                  }</div><div>                  if (paramName != null) {</div><div>                        args[i] = resolveRequestParam(paramName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (headerName != null) {</div><div>                        args[i] = resolveRequestHeader(headerName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (requestBodyFound) {</div><div>                        args[i] = resolveRequestBody(methodParam,  webRequest, handler);</div><div>                  }</div><div>                  else if (cookieName != null) {</div><div>                        args[i] = resolveCookieValue(cookieName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (pathVarName != null) {</div><div>                        args[i] = resolvePathVariable(pathVarName,  methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (attrName != null) {</div><div>                        WebDataBinder binder =</div><div>                                    resolveModelAttribute(attrName,  methodParam, implicitModel, webRequest, handler);</div><div>                        boolean assignBindingResult = (args.length &gt; i +  1 &amp;&amp; Errors.class.isAssignableFrom(paramTypes[i + 1]));</div><div>                        if (binder.getTarget() != null) {</div><div>                              doBind(binder, webRequest, validate,  validationHints, !assignBindingResult);</div><div>                        }</div><div>                        args[i] = binder.getTarget();</div><div>                        if (assignBindingResult) {</div><div>                              args[i + 1] = binder.getBindingResult();</div><div>                              i++;</div><div>                        }</div><div>                        implicitModel.putAll(binder.getBindingResult().getModel());</div><div>                  }</div><div>            }</div><div>            return args;</div><div>      }</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>      public final Object invokeHandlerMethod(Method handlerMethod,  Object handler,</div><div>                  NativeWebRequest webRequest, ExtendedModelMap  implicitModel) throws Exception {</div><div>            Method handlerMethodToInvoke =  BridgeMethodResolver.findBridgedMethod(handlerMethod);</div><div>            try {</div><div>                  boolean debug = logger.isDebugEnabled();</div><div>                  for (String attrName :  this.methodResolver.getActualSessionAttributeNames()) {</div><div>                        Object attrValue =  this.sessionAttributeStore.retrieveAttribute(webRequest, attrName);</div><div>                        if (attrValue != null) {</div><div>                              implicitModel.addAttribute(attrName,  attrValue);</div><div>                        }</div><div>                  }</div><div>                  for (Method attributeMethod :  this.methodResolver.getModelAttributeMethods()) {</div><div>                        Method attributeMethodToInvoke =  BridgeMethodResolver.findBridgedMethod(attributeMethod);</div><div>                      <b><font color="#FF4635">  Object[] args =  resolveHandlerArguments(attributeMethodToInvoke, handler, webRequest,  implicitModel);</font></b></div><div>                        if (debug) {</div><div>                              logger.debug(&quot;Invoking model attribute  method: &quot; + attributeMethodToInvoke);</div><div>                        }</div><div>                        //<b><font color="#FF4635">attrName @ModelAttribute的value值</font></b></div><div>                    <b><font style="color: rgb(235, 0, 115);">    String attrName =  AnnotationUtils.findAnnotation(attributeMethod,  ModelAttribute.class).value();</font></b></div><div>                        if (!&quot;&quot;.equals(attrName) &amp;&amp;  implicitModel.containsAttribute(attrName)) {</div><div>                              continue;</div><div>                        }</div><div>                       <b><font color="#FF4635"> ReflectionUtils.makeAccessible(attributeMethodToInvoke);</font></b></div><div><b><font style="color: rgb(255, 70, 53);">                        Object attrValue =  attributeMethodToInvoke.invoke(handler, args);</font></b></div><div><b><font color="#FF4635">                        if (&quot;&quot;.equals(attrName)) {</font></b></div><div><b><font color="#FF4635">                              Class&lt;?&gt; resolvedType =  GenericTypeResolver.resolveReturnType(attributeMethodToInvoke,  handler.getClass());</font></b></div><div><b><font color="#FF4635"><br/></font></b></div><div><b><font style="color: rgb(255, 70, 53);">                         //</font></b>attrName=void</div><div><b><font style="color: rgb(255, 70, 53);">                              attrName =  Conventions.getVariableNameForReturnType(attributeMethodToInvoke,  resolvedType, attrValue);</font></b></div><div><b><font color="#FF4635">                        }</font></b></div><div><b><font color="#FF4635"><br/></font></b></div><div><b><font color="#000000">//</font></b>{shuihuzhuan=Book [bookName=水浒传, price=100, author=施耐庵]}</div><div>                        if (!implicitModel.containsAttribute(attrName))  {</div><div>                              implicitModel.addAttribute(attrName,  attrValue);</div><div>                        }</div><div>implicitModel  {shuihuzhuan=Book [bookName=水浒传, price=100, author=施耐庵], void=null}</div><div>                  }</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>              <b><i><font color="#EB0073">    Object[] args =  resolveHandlerArguments(handlerMethodToInvoke, handler, webRequest,  implicitModel);</font></i></b></div><div>                  if (debug) {</div><div>                        logger.debug(&quot;Invoking request handler method: &quot;  + handlerMethodToInvoke);</div><div>                  }</div><div>                  ReflectionUtils.makeAccessible(handlerMethodToInvoke);</div><div>//运行目标方法</div><div>               <b><font color="#EB0073">   return handlerMethodToInvoke.invoke(handler, args);</font></b></div><div>            }</div><div>            catch (IllegalStateException ex) {</div><div>                  // Internal assertion failed (e.g. invalid signature):</div><div>                  // throw exception with full handler method context...</div><div>                  throw new  HandlerMethodInvocationException(handlerMethodToInvoke, ex);</div><div>            }</div><div>            catch (InvocationTargetException ex) {</div><div>                  // User-defined  @ModelAttribute/@InitBinder/@RequestMapping method threw an exception...</div><div>                  ReflectionUtils.rethrowException(ex.getTargetException());</div><div>                  return null;</div><div>            }</div><div>      }</div><div>@ModelAttribute标在方法上的另一个作用</div><div><b><font color="#FF0000">可以把方法运行后的返回值放到隐含模型中默认的key是返回值首字母小写,</font></b></div><div><b><font color="#FF0000">可以通过@ModelAttribute(&quot;xxxx&quot;)改变.</font></b></div></div><div>真正方法执行</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>      public final Object invokeHandlerMethod(Method handlerMethod,  Object handler,</div><div>                  NativeWebRequest webRequest, ExtendedModelMap  implicitModel) throws Exception {</div><div>            Method handlerMethodToInvoke =  BridgeMethodResolver.findBridgedMethod(handlerMethod);</div><div>            try {</div><div>                  boolean debug = logger.isDebugEnabled();</div><div>                  for (String attrName :  this.methodResolver.getActualSessionAttributeNames()) {</div><div>                        Object attrValue =  this.sessionAttributeStore.retrieveAttribute(webRequest, attrName);</div><div>                        if (attrValue != null) {</div><div>                              implicitModel.addAttribute(attrName,  attrValue);</div><div>                        }</div><div>                  }</div><div>                  for (Method attributeMethod :  this.methodResolver.getModelAttributeMethods()) {</div><div>                        Method attributeMethodToInvoke =  BridgeMethodResolver.findBridgedMethod(attributeMethod);</div><div>                        Object[] args =  resolveHandlerArguments(attributeMethodToInvoke, handler, webRequest,  implicitModel);</div><div>                        if (debug) {</div><div>                              logger.debug(&quot;Invoking model attribute  method: &quot; + attributeMethodToInvoke);</div><div>                        }</div><div>                        String attrName =  AnnotationUtils.findAnnotation(attributeMethod,  ModelAttribute.class).value();</div><div>                        if (!&quot;&quot;.equals(attrName) &amp;&amp;  implicitModel.containsAttribute(attrName)) {</div><div>                              continue;</div><div>                        }</div><div>                        ReflectionUtils.makeAccessible(attributeMethodToInvoke);</div><div>                        Object attrValue =  attributeMethodToInvoke.invoke(handler, args);</div><div>                        if (&quot;&quot;.equals(attrName)) {</div><div>                              Class&lt;?&gt; resolvedType =  GenericTypeResolver.resolveReturnType(attributeMethodToInvoke,  handler.getClass());</div><div>                              attrName =  Conventions.getVariableNameForReturnType(attributeMethodToInvoke,  resolvedType, attrValue);</div><div>                        }</div><div>                        if (!implicitModel.containsAttribute(attrName))  {</div><div>                              implicitModel.addAttribute(attrName,  attrValue);</div><div>                        }</div><div>                  }</div><div>        <b><font color="#FF0000">          Object[] args =  resolveHandlerArguments(handlerMethodToInvoke, handler, webRequest,  implicitModel);</font></b></div><div>                  if (debug) {</div><div>                        logger.debug(&quot;Invoking request handler method: &quot;  + handlerMethodToInvoke);</div><div>                  }</div><div>                  ReflectionUtils.makeAccessible(handlerMethodToInvoke);</div><div>                  return handlerMethodToInvoke.invoke(handler, args);</div><div>            }</div><div>            catch (IllegalStateException ex) {</div><div>                  // Internal assertion failed (e.g. invalid signature):</div><div>                  // throw exception with full handler method context...</div><div>                  throw new  HandlerMethodInvocationException(handlerMethodToInvoke, ex);</div><div>            }</div><div>            catch (InvocationTargetException ex) {</div><div>                  // User-defined  @ModelAttribute/@InitBinder/@RequestMapping method threw an exception...</div><div>                  ReflectionUtils.rethrowException(ex.getTargetException());</div><div>                  return null;</div><div>            }</div><div>      }</div></div><div>第一个参数获取</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private Object[] resolveHandlerArguments(Method handlerMethod, Object  handler,</div><div>                  NativeWebRequest webRequest, ExtendedModelMap  implicitModel) throws Exception {</div><div>            Class&lt;?&gt;[] paramTypes = handlerMethod.getParameterTypes();</div><div>            Object[] args = new Object[paramTypes.length];</div><div>            for (int i = 0; i &lt; args.length; i++) {</div><div>                  MethodParameter methodParam = new  MethodParameter(handlerMethod, i);</div><div>                  methodParam.initParameterNameDiscovery(this.parameterNameDiscoverer);</div><div>                  GenericTypeResolver.resolveParameterType(methodParam,  handler.getClass());</div><div>                  String paramName = null;</div><div>                  String headerName = null;</div><div>                  boolean requestBodyFound = false;</div><div>                  String cookieName = null;</div><div>                  String pathVarName = null;</div><div>                  String attrName = null;</div><div>                  boolean required = false;</div><div>                  String defaultValue = null;</div><div>                  boolean validate = false;</div><div>                  Object[] validationHints = null;</div><div>                  int annotationsFound = 0;</div><div>                  Annotation[] paramAnns =  methodParam.getParameterAnnotations();</div><div>                  for (Annotation paramAnn : paramAnns) {</div><div>                   <b><font color="#EB0073">     if (RequestParam.class.isInstance(paramAnn)) {</font></b></div><div><b><font color="#EB0073">                              RequestParam requestParam = (RequestParam)  paramAnn;</font></b></div><div><b><font color="#FF0000">//paramName 为author</font></b></div><div><b><font style="color: rgb(235, 0, 115);">                              paramName = requestParam.value();</font></b></div><div><b><font color="#EB0073">                              required = requestParam.required();</font></b></div><div><b><font color="#EB0073">                              defaultValue =  parseDefaultValueAttribute(requestParam.defaultValue());</font></b></div><div><b><font color="#EB0073">                              annotationsFound++;</font></b></div><div><b><font color="#EB0073">                        }</font></b></div><div>                        else if  (RequestHeader.class.isInstance(paramAnn)) {</div><div>                              RequestHeader requestHeader =  (RequestHeader) paramAnn;</div><div>                              headerName = requestHeader.value();</div><div>                              required = requestHeader.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(requestHeader.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (RequestBody.class.isInstance(paramAnn))  {</div><div>                              requestBodyFound = true;</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (CookieValue.class.isInstance(paramAnn))  {</div><div>                              CookieValue cookieValue = (CookieValue)  paramAnn;</div><div>                              cookieName = cookieValue.value();</div><div>                              required = cookieValue.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(cookieValue.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (PathVariable.class.isInstance(paramAnn)) {</div><div>                              PathVariable pathVar = (PathVariable)  paramAnn;</div><div>                              pathVarName = pathVar.value();</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (ModelAttribute.class.isInstance(paramAnn)) {</div><div>                              ModelAttribute attr = (ModelAttribute)  paramAnn;</div><div>                              attrName = attr.value();</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (Value.class.isInstance(paramAnn)) {</div><div>                              defaultValue = ((Value) paramAnn).value();</div><div>                        }</div><div>                        else if  (paramAnn.annotationType().getSimpleName().startsWith(&quot;Valid&quot;)) {</div><div>                              validate = true;</div><div>                              Object value =  AnnotationUtils.getValue(paramAnn);</div><div>                              validationHints = (value instanceof  Object[] ? (Object[]) value : new Object[] {value});</div><div>                        }</div><div>                  }</div><div>                  if (annotationsFound &gt; 1) {</div><div>                        throw new IllegalStateException(&quot;Handler  parameter annotations are exclusive choices - &quot; +</div><div>                                    &quot;do not specify more than one such  annotation on the same parameter: &quot; + handlerMethod);</div><div>                  }</div><div>                  if (annotationsFound == 0) {</div><div>                        Object argValue =  resolveCommonArgument(methodParam, webRequest);</div><div>                        if (argValue != WebArgumentResolver.UNRESOLVED)  {</div><div>                              args[i] = argValue;</div><div>                        }</div><div>                        else if (defaultValue != null) {</div><div>                              args[i] =  resolveDefaultValue(defaultValue);</div><div>                        }</div><div>                        else {</div><div>                              Class&lt;?&gt; paramType =  methodParam.getParameterType();</div><div>                              if  (Model.class.isAssignableFrom(paramType) ||  Map.class.isAssignableFrom(paramType)) {</div><div>                                    if  (!paramType.isAssignableFrom(implicitModel.getClass())) {</div><div>                                          throw new  IllegalStateException(&quot;Argument [&quot; + paramType.getSimpleName() + &quot;] is  of type &quot; +</div><div>                                                      &quot;Model or Map but  is not assignable from the actual model. You may need to switch &quot; +</div><div>                                                      &quot;newer MVC  infrastructure classes to use this argument.&quot;);</div><div>                                    }</div><div>                                    args[i] = implicitModel;</div><div>                              }</div><div>                              else if  (SessionStatus.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] = this.sessionStatus;</div><div>                              }</div><div>                              else if  (HttpEntity.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] =  resolveHttpEntityRequest(methodParam, webRequest);</div><div>                              }</div><div>                              else if  (Errors.class.isAssignableFrom(paramType)) {</div><div>                                    throw new  IllegalStateException(&quot;Errors/BindingResult argument declared &quot; +</div><div>                                                &quot;without preceding model  attribute. Check your handler method signature!&quot;);</div><div>                              }</div><div>                              else if  (BeanUtils.isSimpleProperty(paramType)) {</div><div>                                    paramName = &quot;&quot;;</div><div>                              }</div><div>                              else {</div><div>                                    attrName = &quot;&quot;;</div><div>                              }</div><div>                        }</div><div>                  }</div><div>                  if (paramName != null) {</div><div>                     <b><font color="#FF0000">   args[i] = resolveRequestParam(paramName,  required, defaultValue, methodParam, webRequest, handler);</font></b></div><div>                  }</div><div>                  else if (headerName != null) {</div><div>                        args[i] = resolveRequestHeader(headerName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (requestBodyFound) {</div><div>                        args[i] = resolveRequestBody(methodParam,  webRequest, handler);</div><div>                  }</div><div>                  else if (cookieName != null) {</div><div>                        args[i] = resolveCookieValue(cookieName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (pathVarName != null) {</div><div>                        args[i] = resolvePathVariable(pathVarName,  methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (attrName != null) {</div><div>                        WebDataBinder binder =</div><div>                                    resolveModelAttribute(attrName,  methodParam, implicitModel, webRequest, handler);</div><div>                        boolean assignBindingResult = (args.length &gt; i +  1 &amp;&amp; Errors.class.isAssignableFrom(paramTypes[i + 1]));</div><div>                        if (binder.getTarget() != null) {</div><div>                              doBind(binder, webRequest, validate,  validationHints, !assignBindingResult);</div><div>                        }</div><div>                        args[i] = binder.getTarget();</div><div>                        if (assignBindingResult) {</div><div>                              args[i + 1] = binder.getBindingResult();</div><div>                              i++;</div><div>                        }</div><div>                        implicitModel.putAll(binder.getBindingResult().getModel());</div><div>                  }</div><div>            }</div><div>            return args;</div><div>      }</div><div><br/></div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>private Object <b><font color="#FF0000">resolveRequestParam(String paramName, boolean required,  String defaultValue,</font></b></div><div>                  MethodParameter methodParam, NativeWebRequest  webRequest, Object handlerForInitBinderCall)</div><div>                  throws Exception {</div><div>            Class&lt;?&gt; paramType = methodParam.getParameterType();</div><div>            if (Map.class.isAssignableFrom(paramType) &amp;&amp;  paramName.length() == 0) {</div><div>                  return resolveRequestParamMap((Class&lt;? extends Map&lt;?,  ?&gt;&gt;) paramType, webRequest);</div><div>            }</div><div>            if (paramName.length() == 0) {</div><div>                  paramName = getRequiredParameterName(methodParam);</div><div>            }</div><div>            Object paramValue = null;</div><div>            MultipartRequest multipartRequest =  webRequest.getNativeRequest(MultipartRequest.class);</div><div>            if (multipartRequest != null) {</div><div>                  List&lt;MultipartFile&gt; files =  multipartRequest.getFiles(paramName);</div><div>                  if (!files.isEmpty()) {</div><div>                        paramValue = (files.size() == 1 ? files.get(0) :  files);</div><div>                  }</div><div>            }</div><div><b><font color="#FF0000">//paramValue 施耐庵</font></b></div><div>            if (paramValue == null) {</div><div>                <b><font color="#FF4635">  String[] paramValues =  webRequest.getParameterValues(paramName);</font></b></div><div>                <b><font color="#FF0000">  if (paramValues != null) {</font></b></div><div><b><font style="color: rgb(255, 0, 0);">                        paramValue = (paramValues.length == 1 ?  paramValues[0] : paramValues);</font></b></div><div><b><font color="#FF0000">                  }</font></b></div><div>            }</div><div>            if (paramValue == null) {</div><div>                  if (defaultValue != null) {</div><div>                        paramValue = resolveDefaultValue(defaultValue);</div><div>                  }</div><div>                  else if (required) {</div><div>                        raiseMissingParameterException(paramName,  paramType);</div><div>                  }</div><div>                  paramValue = checkValue(paramName, paramValue,  paramType);</div><div>            }</div><div>            WebDataBinder binder = createBinder(webRequest, null,  paramName);</div><div>            initBinder(handlerForInitBinderCall, paramName, binder,  webRequest);</div><div>            return binder.convertIfNecessary(paramValue, paramType,  methodParam);</div><div>      }</div></div><div><span style="font-size: 12pt;">第二个参数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private Object[] resolveHandlerArguments(Method handlerMethod, Object  handler,</div><div>                  NativeWebRequest webRequest, ExtendedModelMap  implicitModel) throws Exception {</div><div>            Class&lt;?&gt;[] paramTypes = handlerMethod.getParameterTypes();</div><div>            Object[] args = new Object[paramTypes.length];</div><div>            for (int i = 0; i &lt; args.length; i++) {</div><div>                  MethodParameter methodParam = new  MethodParameter(handlerMethod, i);</div><div>                  methodParam.initParameterNameDiscovery(this.parameterNameDiscoverer);</div><div>                  GenericTypeResolver.resolveParameterType(methodParam,  handler.getClass());</div><div>                  String paramName = null;</div><div>                  String headerName = null;</div><div>                  boolean requestBodyFound = false;</div><div>                  String cookieName = null;</div><div>                  String pathVarName = null;</div><div>                  String attrName = null;</div><div>                  boolean required = false;</div><div>                  String defaultValue = null;</div><div>                  boolean validate = false;</div><div>                  Object[] validationHints = null;</div><div>                  int annotationsFound = 0;</div><div>                  Annotation[] paramAnns =  methodParam.getParameterAnnotations();</div><div>                  for (Annotation paramAnn : paramAnns) {</div><div>                        if (RequestParam.class.isInstance(paramAnn)) {</div><div>                              RequestParam requestParam = (RequestParam)  paramAnn;</div><div>                              paramName = requestParam.value();</div><div>                              required = requestParam.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(requestParam.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (RequestHeader.class.isInstance(paramAnn)) {</div><div>                              RequestHeader requestHeader =  (RequestHeader) paramAnn;</div><div>                              headerName = requestHeader.value();</div><div>                              required = requestHeader.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(requestHeader.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (RequestBody.class.isInstance(paramAnn))  {</div><div>                              requestBodyFound = true;</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (CookieValue.class.isInstance(paramAnn))  {</div><div>                              CookieValue cookieValue = (CookieValue)  paramAnn;</div><div>                              cookieName = cookieValue.value();</div><div>                              required = cookieValue.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(cookieValue.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (PathVariable.class.isInstance(paramAnn)) {</div><div>                              PathVariable pathVar = (PathVariable)  paramAnn;</div><div>                              pathVarName = pathVar.value();</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (ModelAttribute.class.isInstance(paramAnn)) {</div><div>                              ModelAttribute attr = (ModelAttribute)  paramAnn;</div><div>                              attrName = attr.value();</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (Value.class.isInstance(paramAnn)) {</div><div>                              defaultValue = ((Value) paramAnn).value();</div><div>                        }</div><div>                        else if  (paramAnn.annotationType().getSimpleName().startsWith(&quot;Valid&quot;)) {</div><div>                              validate = true;</div><div>                              Object value =  AnnotationUtils.getValue(paramAnn);</div><div>                              validationHints = (value instanceof  Object[] ? (Object[]) value : new Object[] {value});</div><div>                        }</div><div>                  }</div><div>                  if (annotationsFound &gt; 1) {</div><div>                        throw new IllegalStateException(&quot;Handler  parameter annotations are exclusive choices - &quot; +</div><div>                                    &quot;do not specify more than one such  annotation on the same parameter: &quot; + handlerMethod);</div><div>                  }</div><div>                 <b><font color="#FF4635"> if (annotationsFound == 0) {</font></b></div><div>                       <b><font color="#FF0000"> Object argValue =  resolveCommonArgument(methodParam, webRequest);</font></b></div><div>                        if (argValue != WebArgumentResolver.UNRESOLVED)  {</div><div>                              args[i] = argValue;</div><div>                        }</div><div>                        else if (defaultValue != null) {</div><div>                              args[i] =  resolveDefaultValue(defaultValue);</div><div>                        }</div><div>                        else {</div><div>                              Class&lt;?&gt; paramType =  methodParam.getParameterType();</div><div>                           <b><font color="#FF0000">   if  (Model.class.isAssignableFrom(paramType) ||  Map.class.isAssignableFrom(paramType)) {</font></b></div><div><b><font color="#FF0000">                                    if  (!paramType.isAssignableFrom(implicitModel.getClass())) {</font></b></div><div><b><font color="#FF0000">                                          throw new  IllegalStateException(&quot;Argument [&quot; + paramType.getSimpleName() + &quot;] is  of type &quot; +</font></b></div><div><b><font color="#FF0000">                                                      &quot;Model or Map but  is not assignable from the actual model. You may need to switch &quot; +</font></b></div><div><b><font color="#FF0000">                                                      &quot;newer MVC  infrastructure classes to use this argument.&quot;);</font></b></div><div><b><font color="#FF0000">                                    }</font></b></div><div><b><font color="#FF0000">                                    args[i] = implicitModel;</font></b></div><div><b><font color="#FF0000">                              }</font></b></div><div>                              else if  (SessionStatus.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] = this.sessionStatus;</div><div>                              }</div><div>                              else if  (HttpEntity.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] =  resolveHttpEntityRequest(methodParam, webRequest);</div><div>                              }</div><div>                              else if  (Errors.class.isAssignableFrom(paramType)) {</div><div>                                    throw new  IllegalStateException(&quot;Errors/BindingResult argument declared &quot; +</div><div>                                                &quot;without preceding model  attribute. Check your handler method signature!&quot;);</div><div>                              }</div><div>                              else if  (BeanUtils.isSimpleProperty(paramType)) {</div><div>                                    paramName = &quot;&quot;;</div><div>                              }</div><div>                              else {</div><div>                                    attrName = &quot;&quot;;</div><div>                              }</div><div>                        }</div><div>                  }</div><div>                  if (paramName != null) {</div><div>                        args[i] = resolveRequestParam(paramName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (headerName != null) {</div><div>                        args[i] = resolveRequestHeader(headerName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (requestBodyFound) {</div><div>                        args[i] = resolveRequestBody(methodParam,  webRequest, handler);</div><div>                  }</div><div>                  else if (cookieName != null) {</div><div>                        args[i] = resolveCookieValue(cookieName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (pathVarName != null) {</div><div>                        args[i] = resolvePathVariable(pathVarName,  methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (attrName != null) {</div><div>                        WebDataBinder binder =</div><div>                                    resolveModelAttribute(attrName,  methodParam, implicitModel, webRequest, handler);</div><div>                        boolean assignBindingResult = (args.length &gt; i +  1 &amp;&amp; Errors.class.isAssignableFrom(paramTypes[i + 1]));</div><div>                        if (binder.getTarget() != null) {</div><div>                              doBind(binder, webRequest, validate,  validationHints, !assignBindingResult);</div><div>                        }</div><div>                        args[i] = binder.getTarget();</div><div>                        if (assignBindingResult) {</div><div>                              args[i + 1] = binder.getBindingResult();</div><div>                              i++;</div><div>                        }</div><div>                        implicitModel.putAll(binder.getBindingResult().getModel());</div><div>                  }</div><div>            }</div><div>            return args;</div><div>      }</div></div><div><span style="font-size: 12pt;">第三</span><span style="font-size: 12pt;">个参数 HttpServletRequest request,</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private Object[] resolveHandlerArguments(Method handlerMethod, Object  handler,</div><div>                  NativeWebRequest webRequest, ExtendedModelMap  implicitModel) throws Exception {</div><div>            Class&lt;?&gt;[] paramTypes = handlerMethod.getParameterTypes();</div><div>            Object[] args = new Object[paramTypes.length];</div><div>            for (int i = 0; i &lt; args.length; i++) {</div><div>                  MethodParameter methodParam = new  MethodParameter(handlerMethod, i);</div><div>                  methodParam.initParameterNameDiscovery(this.parameterNameDiscoverer);</div><div>                  GenericTypeResolver.resolveParameterType(methodParam,  handler.getClass());</div><div>                  String paramName = null;</div><div>                  String headerName = null;</div><div>                  boolean requestBodyFound = false;</div><div>                  String cookieName = null;</div><div>                  String pathVarName = null;</div><div>                  String attrName = null;</div><div>                  boolean required = false;</div><div>                  String defaultValue = null;</div><div>                  boolean validate = false;</div><div>                  Object[] validationHints = null;</div><div>                  int annotationsFound = 0;</div><div>                  Annotation[] paramAnns =  methodParam.getParameterAnnotations();</div><div>                  for (Annotation paramAnn : paramAnns) {</div><div>                        if (RequestParam.class.isInstance(paramAnn)) {</div><div>                              RequestParam requestParam = (RequestParam)  paramAnn;</div><div>                              paramName = requestParam.value();</div><div>                              required = requestParam.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(requestParam.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (RequestHeader.class.isInstance(paramAnn)) {</div><div>                              RequestHeader requestHeader =  (RequestHeader) paramAnn;</div><div>                              headerName = requestHeader.value();</div><div>                              required = requestHeader.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(requestHeader.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (RequestBody.class.isInstance(paramAnn))  {</div><div>                              requestBodyFound = true;</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (CookieValue.class.isInstance(paramAnn))  {</div><div>                              CookieValue cookieValue = (CookieValue)  paramAnn;</div><div>                              cookieName = cookieValue.value();</div><div>                              required = cookieValue.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(cookieValue.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (PathVariable.class.isInstance(paramAnn)) {</div><div>                              PathVariable pathVar = (PathVariable)  paramAnn;</div><div>                              pathVarName = pathVar.value();</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (ModelAttribute.class.isInstance(paramAnn)) {</div><div>                              ModelAttribute attr = (ModelAttribute)  paramAnn;</div><div>                              attrName = attr.value();</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (Value.class.isInstance(paramAnn)) {</div><div>                              defaultValue = ((Value) paramAnn).value();</div><div>                        }</div><div>                        else if  (paramAnn.annotationType().getSimpleName().startsWith(&quot;Valid&quot;)) {</div><div>                              validate = true;</div><div>                              Object value =  AnnotationUtils.getValue(paramAnn);</div><div>                              validationHints = (value instanceof  Object[] ? (Object[]) value : new Object[] {value});</div><div>                        }</div><div>                  }</div><div>                  if (annotationsFound &gt; 1) {</div><div>                        throw new IllegalStateException(&quot;Handler  parameter annotations are exclusive choices - &quot; +</div><div>                                    &quot;do not specify more than one such  annotation on the same parameter: &quot; + handlerMethod);</div><div>                  }</div><div>                  if (annotationsFound == 0) {</div><div>                     <font color="#FF0000"><b>   Object argValue =  resolveCommonArgument(methodParam, webRequest);</b></font></div><div>                        if (argValue != WebArgumentResolver.UNRESOLVED)  {</div><div>//org.apache.catalina.connector.Request@734a2a10</div><div>                             <b><font color="#FF0000"> args[i] = argValue;</font></b></div><div>                        }</div><div>                        else if (defaultValue != null) {</div><div>                              args[i] =  resolveDefaultValue(defaultValue);</div><div>                        }</div><div>                        else {</div><div>                              Class&lt;?&gt; paramType =  methodParam.getParameterType();</div><div>                              if  (Model.class.isAssignableFrom(paramType) ||  Map.class.isAssignableFrom(paramType)) {</div><div>                                    if  (!paramType.isAssignableFrom(implicitModel.getClass())) {</div><div>                                          throw new  IllegalStateException(&quot;Argument [&quot; + paramType.getSimpleName() + &quot;] is  of type &quot; +</div><div>                                                      &quot;Model or Map but  is not assignable from the actual model. You may need to switch &quot; +</div><div>                                                      &quot;newer MVC  infrastructure classes to use this argument.&quot;);</div><div>                                    }</div><div>                                    args[i] = implicitModel;</div><div>                              }</div><div>                              else if  (SessionStatus.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] = this.sessionStatus;</div><div>                              }</div><div>                              else if  (HttpEntity.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] =  resolveHttpEntityRequest(methodParam, webRequest);</div><div>                              }</div><div>                              else if  (Errors.class.isAssignableFrom(paramType)) {</div><div>                                    throw new  IllegalStateException(&quot;Errors/BindingResult argument declared &quot; +</div><div>                                                &quot;without preceding model  attribute. Check your handler method signature!&quot;);</div><div>                              }</div><div>                              else if  (BeanUtils.isSimpleProperty(paramType)) {</div><div>                                    paramName = &quot;&quot;;</div><div>                              }</div><div>                              else {</div><div>                                    attrName = &quot;&quot;;</div><div>                              }</div><div>                        }</div><div>                  }</div><div>                  if (paramName != null) {</div><div>                        args[i] = resolveRequestParam(paramName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (headerName != null) {</div><div>                        args[i] = resolveRequestHeader(headerName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (requestBodyFound) {</div><div>                        args[i] = resolveRequestBody(methodParam,  webRequest, handler);</div><div>                  }</div><div>                  else if (cookieName != null) {</div><div>                        args[i] = resolveCookieValue(cookieName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (pathVarName != null) {</div><div>                        args[i] = resolvePathVariable(pathVarName,  methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (attrName != null) {</div><div>                        WebDataBinder binder =</div><div>                                    resolveModelAttribute(attrName,  methodParam, implicitModel, webRequest, handler);</div><div>                        boolean assignBindingResult = (args.length &gt; i +  1 &amp;&amp; Errors.class.isAssignableFrom(paramTypes[i + 1]));</div><div>                        if (binder.getTarget() != null) {</div><div>                              doBind(binder, webRequest, validate,  validationHints, !assignBindingResult);</div><div>                        }</div><div>                        args[i] = binder.getTarget();</div><div>                        if (assignBindingResult) {</div><div>                              args[i + 1] = binder.getBindingResult();</div><div>                              i++;</div><div>                        }</div><div>                        implicitModel.putAll(binder.getBindingResult().getModel());</div><div>                  }</div><div>            }</div><div>            return args;</div><div>      }</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>protected Object resolveCommonArgument(MethodParameter methodParameter,  NativeWebRequest webRequest)</div><div>                  throws Exception {</div><div>            // Invoke custom argument resolvers if present...</div><div>            if (this.customArgumentResolvers != null) {</div><div>                  for (WebArgumentResolver argumentResolver :  this.customArgumentResolvers) {</div><div>                        Object value =  argumentResolver.resolveArgument(methodParameter, webRequest);</div><div>                        if (value != WebArgumentResolver.UNRESOLVED) {</div><div>                              return value;</div><div>                        }</div><div>                  }</div><div>            }</div><div>            // Resolution of standard parameter types...</div><div>            Class&lt;?&gt; paramType = methodParameter.getParameterType();</div><div><b><font color="#FF0000">            Object value = resolveStandardArgument(paramType,  webRequest);</font></b></div><div>            if (value != WebArgumentResolver.UNRESOLVED &amp;&amp;  !ClassUtils.isAssignableValue(paramType, value)) {</div><div>                  throw new IllegalStateException(&quot;Standard argument  type [&quot; + paramType.getName() +</div><div>                              &quot;] resolved to incompatible value of type  [&quot; + (value != null ? value.getClass() : null) +</div><div>                              &quot;]. Consider declaring the argument type  in a less specific fashion.&quot;);</div><div>            }</div><div>            return value;</div><div>      }</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>      protected Object resolveStandardArgument(Class&lt;?&gt; parameterType,  NativeWebRequest webRequest) throws Exception {</div><div>                  HttpServletRequest request =  webRequest.getNativeRequest(HttpServletRequest.class);</div><div>                  HttpServletResponse response =  webRequest.getNativeResponse(HttpServletResponse.class);</div><div>        <font color="#BC0058"><b>          if  (ServletRequest.class.isAssignableFrom(parameterType) ||</b></font></div><div><font color="#BC0058"><b>                              MultipartRequest.class.isAssignableFrom(parameterType)) {</b></font></div><div><font color="#BC0058"><b>                        Object nativeRequest =  webRequest.getNativeRequest(parameterType);</b></font></div><div>                        if (nativeRequest == null) {</div><div>                              throw new IllegalStateException(</div><div>                                          &quot;Current request is not of  type [&quot; + parameterType.getName() + &quot;]: &quot; + request);</div><div>                        }</div><div>                  <b><font color="#FF0000">      return nativeRequest;</font></b></div><div>                  }</div><div>                  else if  (ServletResponse.class.isAssignableFrom(parameterType)) {</div><div>                        this.responseArgumentUsed = true;</div><div>                        Object nativeResponse =  webRequest.getNativeResponse(parameterType);</div><div>                        if (nativeResponse == null) {</div><div>                              throw new IllegalStateException(</div><div>                                          &quot;Current response is not of  type [&quot; + parameterType.getName() + &quot;]: &quot; + response);</div><div>                        }</div><div>                        return nativeResponse;</div><div>                  }</div><div>                  else if  (HttpSession.class.isAssignableFrom(parameterType)) {</div><div>                        return request.getSession();</div><div>                  }</div><div>                  else if  (Principal.class.isAssignableFrom(parameterType)) {</div><div>                        return request.getUserPrincipal();</div><div>                  }</div><div>                  else if (Locale.class.equals(parameterType)) {</div><div>                        return RequestContextUtils.getLocale(request);</div><div>                  }</div><div>                  else if  (InputStream.class.isAssignableFrom(parameterType)) {</div><div>                        return request.getInputStream();</div><div>                  }</div><div>                  else if (Reader.class.isAssignableFrom(parameterType))  {</div><div>                        return request.getReader();</div><div>                  }</div><div>                  else if  (OutputStream.class.isAssignableFrom(parameterType)) {</div><div>                        this.responseArgumentUsed = true;</div><div>                        return response.getOutputStream();</div><div>                  }</div><div>                  else if (Writer.class.isAssignableFrom(parameterType))  {</div><div>                        this.responseArgumentUsed = true;</div><div>                        return response.getWriter();</div><div>                  }</div><div>                  return super.resolveStandardArgument(parameterType,  webRequest);</div><div>            }</div></div><div>第四个参数  @ModelAttribute(&quot;shuihuzhuan&quot;)Book book</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div> </div><div>      private Object[] resolveHandlerArguments(Method handlerMethod,  Object handler,</div><div>                  NativeWebRequest webRequest, ExtendedModelMap  implicitModel) throws Exception {</div><div>            Class&lt;?&gt;[] paramTypes = handlerMethod.getParameterTypes();</div><div>            Object[] args = new Object[paramTypes.length];</div><div>            for (int i = 0; i &lt; args.length; i++) {</div><div>                  MethodParameter methodParam = new  MethodParameter(handlerMethod, i);</div><div>                  methodParam.initParameterNameDiscovery(this.parameterNameDiscoverer);</div><div>                  GenericTypeResolver.resolveParameterType(methodParam,  handler.getClass());</div><div>                  String paramName = null;</div><div>                  String headerName = null;</div><div>                  boolean requestBodyFound = false;</div><div>                  String cookieName = null;</div><div>                  String pathVarName = null;</div><div>                  String attrName = null;</div><div>                  boolean required = false;</div><div>                  String defaultValue = null;</div><div>                  boolean validate = false;</div><div>                  Object[] validationHints = null;</div><div>                  int annotationsFound = 0;</div><div>                  Annotation[] paramAnns =  methodParam.getParameterAnnotations();</div><div>                  for (Annotation paramAnn : paramAnns) {</div><div>                        if (RequestParam.class.isInstance(paramAnn)) {</div><div>                              RequestParam requestParam = (RequestParam)  paramAnn;</div><div>                              paramName = requestParam.value();</div><div>                              required = requestParam.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(requestParam.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (RequestHeader.class.isInstance(paramAnn)) {</div><div>                              RequestHeader requestHeader =  (RequestHeader) paramAnn;</div><div>                              headerName = requestHeader.value();</div><div>                              required = requestHeader.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(requestHeader.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (RequestBody.class.isInstance(paramAnn))  {</div><div>                              requestBodyFound = true;</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (CookieValue.class.isInstance(paramAnn))  {</div><div>                              CookieValue cookieValue = (CookieValue)  paramAnn;</div><div>                              cookieName = cookieValue.value();</div><div>                              required = cookieValue.required();</div><div>                              defaultValue =  parseDefaultValueAttribute(cookieValue.defaultValue());</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (PathVariable.class.isInstance(paramAnn)) {</div><div>                              PathVariable pathVar = (PathVariable)  paramAnn;</div><div>                              pathVarName = pathVar.value();</div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if  (ModelAttribute.class.isInstance(paramAnn)) {</div><div>                      <b><font color="#FF0000">        ModelAttribute attr = (ModelAttribute)  paramAnn;</font></b></div><div><b><font color="#FF0000">//attrName=</font></b><font color="#FF0000"><b>shuihuzhuan</b></font></div><div><b><font style="color: rgb(255, 0, 0);">                              attrName = attr.value();</font></b></div><div>                              annotationsFound++;</div><div>                        }</div><div>                        else if (Value.class.isInstance(paramAnn)) {</div><div>                              defaultValue = ((Value) paramAnn).value();</div><div>                        }</div><div>                        else if  (paramAnn.annotationType().getSimpleName().startsWith(&quot;Valid&quot;)) {</div><div>                              validate = true;</div><div>                              Object value =  AnnotationUtils.getValue(paramAnn);</div><div>                              validationHints = (value instanceof  Object[] ? (Object[]) value : new Object[] {value});</div><div>                        }</div><div>                  }</div><div>                  if (annotationsFound &gt; 1) {</div><div>                        throw new IllegalStateException(&quot;Handler  parameter annotations are exclusive choices - &quot; +</div><div>                                    &quot;do not specify more than one such  annotation on the same parameter: &quot; + handlerMethod);</div><div>                  }</div><div>                  if (annotationsFound == 0) {</div><div>                        Object argValue =  resolveCommonArgument(methodParam, webRequest);</div><div>                        if (argValue != WebArgumentResolver.UNRESOLVED)  {</div><div>                              args[i] = argValue;</div><div>                        }</div><div>                        else if (defaultValue != null) {</div><div>                              args[i] =  resolveDefaultValue(defaultValue);</div><div>                        }</div><div>                        else {</div><div>                              Class&lt;?&gt; paramType =  methodParam.getParameterType();</div><div>                              if  (Model.class.isAssignableFrom(paramType) ||  Map.class.isAssignableFrom(paramType)) {</div><div>                                    if  (!paramType.isAssignableFrom(implicitModel.getClass())) {</div><div>                                          throw new  IllegalStateException(&quot;Argument [&quot; + paramType.getSimpleName() + &quot;] is  of type &quot; +</div><div>                                                      &quot;Model or Map but  is not assignable from the actual model. You may need to switch &quot; +</div><div>                                                      &quot;newer MVC  infrastructure classes to use this argument.&quot;);</div><div>                                    }</div><div>                                    args[i] = implicitModel;</div><div>                              }</div><div>                              else if  (SessionStatus.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] = this.sessionStatus;</div><div>                              }</div><div>                              else if  (HttpEntity.class.isAssignableFrom(paramType)) {</div><div>                                    args[i] =  resolveHttpEntityRequest(methodParam, webRequest);</div><div>                              }</div><div>                              else if  (Errors.class.isAssignableFrom(paramType)) {</div><div>                                    throw new  IllegalStateException(&quot;Errors/BindingResult argument declared &quot; +</div><div>                                                &quot;without preceding model  attribute. Check your handler method signature!&quot;);</div><div>                              }</div><div>                       <b style="color: rgb(50, 135, 18);"> </b><font color="#000000">    如果没有标注解,判断是否是简单属性</font></div><div><font color="#000000">                              else if  (BeanUtils.isSimpleProperty(paramType)) {</font></div><div><font color="#000000">                                    paramName = &quot;&quot;;</font></div><div><font color="#000000">                              }</font></div><div><b><font color="#328712">                              else {</font></b></div><div><b><font color="#328712">                                    attrName = &quot;&quot;;</font></b></div><div><b><font color="#328712">                              }</font></b></div><div>                        }</div><div>                  }</div><div>                  if (paramName != null) {</div><div>              <font color="#000000"><b>  </b>  args[i] = resolveRequestParam(paramName,  required, defaultValue, methodParam, webRequest, handler);</font></div><div>                  }</div><div>                  else if (headerName != null) {</div><div>                        args[i] = resolveRequestHeader(headerName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (requestBodyFound) {</div><div>                        args[i] = resolveRequestBody(methodParam,  webRequest, handler);</div><div>                  }</div><div>                  else if (cookieName != null) {</div><div>                        args[i] = resolveCookieValue(cookieName,  required, defaultValue, methodParam, webRequest, handler);</div><div>                  }</div><div>                  else if (pathVarName != null) {</div><div>                        args[i] = resolvePathVariable(pathVarName,  methodParam, webRequest, handler);</div><div>                  }</div><div>           <font color="#4DCE1D" style="font-weight: bold;">  </font><font color="#4DCE1D">  </font><font color="#000000"><font>   </font>else if (attrName != null) {</font></div><div><font color="#000000">                        WebDataBinder binder =</font></div><div><font color="#E30000"><b>//从隐含对象中获取----&gt;sesion----&gt;new对象</b></font></div><div><font color="#328712" style="font-weight: bold;">                        </font><font style="color: rgb(227, 0, 0);"><b>resolveModelAttribute(attrName,  methodParam, implicitModel, webRequest, handler);</b></font></div><div><b style="color: rgb(50, 135, 18);">               </b><font color="#000000">         boolean assignBindingResult = (args.length &gt; i +  1 &amp;&amp; Errors.class.isAssignableFrom(paramTypes[i + 1]));</font></div><div><font color="#000000">                     </font><b><font color="#FF0000">   if (binder.getTarget() != null) {</font></b></div><div><b><font color="#FF0000">//将请求中的数据绑定进来</font></b></div><div><b><font color="#328712">                       </font><font color="#E30000">  doBind(binder, webRequest, validate,  validationHints, !assignBindingResult);</font></b></div><div><font color="#328712" style="font-weight: bold;">                       </font><font color="#000000"> }</font></div><div><font color="#000000">                        args[i] = binder.getTarget();</font></div><div><font color="#000000">                        if (assignBindingResult) {</font></div><div><font color="#000000">                              args[i + 1] = binder.getBindingResult();</font></div><div><font color="#000000">                              i++;</font></div><div><font color="#000000">                        }</font></div><div><font color="#000000">                        implicitModel.putAll(binder.getBindingResult().getModel());</font></div><div><font color="#328712"><b>                  }</b></font></div><div>            }</div><div>            return args;</div><div>      }</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>private WebDataBinder <b><font color="#328712">resolveModelAttribute</font></b>(String attrName,  MethodParameter methodParam,</div><div>                  ExtendedModelMap implicitModel, NativeWebRequest  webRequest, Object handler) throws Exception {</div><div>            // Bind request parameter onto object...</div><div>            String name = attrName;</div><div>            if (&quot;&quot;.equals(name)) {</div><div>//name  =  将参数类型的首字母小写  Book---&gt;book</div><div>                <b><font color="#41AD1C">  name =  Conventions.getVariableNameForParameter(methodParam);</font></b></div><div>            }</div><div>            Class&lt;?&gt; paramType = methodParam.getParameterType();</div><div>            Object bindObject;</div><div><b><font color="#FF0000">//隐含模型中是否有 book </font></b></div><div>          <font color="#FF0000"><b>  if (implicitModel.containsKey(name)) {</b></font></div><div>             <font color="#FF0000"><b>     bindObject = implicitModel.get(name);</b></font></div><div>            }</div><div><font color="#FF0000"><b>@SessionAttributes(value={&quot;key&quot;}) 是否有该key</b></font></div><div>            else if (<font color="#FF0000"><b>this.methodResolver.isSessionAttribute(name,  paramType))</b></font> {</div><div>                  bindObject =  this.sessionAttributeStore.retrieveAttribute(webRequest, name);</div><div>                  if (bindObject == null) {</div><div>                        raiseSessionRequiredException(&quot;Session attribute  '&quot; + name + &quot;' required - not found in session&quot;);</div><div>                  }</div><div>            }</div><div>            else {</div><div>                <b><font color="#FF0000">  bindObject = BeanUtils.instantiateClass(paramType);</font></b></div><div>            }</div><div>            WebDataBinder binder = createBinder(webRequest, bindObject,  name);</div><div>            initBinder(handler, name, binder, webRequest);</div><div>            return binder;</div><div>      }</div></div><div><font style="font-size: 12pt;"><br/></font></div><div><br/></div></span>
</div></body></html> 