<html>
<head>
  <title>interceptor</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/604762 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="694"/>
<h1>interceptor</h1>

<div>
<span><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>protected void doDispatch(HttpServletRequest request,  HttpServletResponse response) throws Exception {</div><div>            HttpServletRequest processedRequest = request;</div><div>            HandlerExecutionChain mappedHandler = null;</div><div>            boolean multipartRequestParsed = false;</div><div>            WebAsyncManager asyncManager =  WebAsyncUtils.getAsyncManager(request);</div><div>            try {</div><div>                  ModelAndView mv = null;</div><div>                  Exception dispatchException = null;</div><div>                  try {</div><div>                        processedRequest = checkMultipart(request);</div><div>                        multipartRequestParsed = processedRequest !=  request;</div><div>                        // Determine handler for the current request.</div><div>                     <b><font color="#FF0000">   mappedHandler = getHandler(processedRequest);</font></b></div><div><b><font color="#FF0000">//拿到三个拦截器</font></b></div><div><b><font color="#FF0000">HandlerExecutionChain with handler [public java.lang.String  com.atguigu.controller.InterceptorController.testupload()] and 3  interceptors</font></b></div><div><b><font color="#E30000">org.springframework.web.servlet.handler.ConversionServiceExposingInterceptor@5f4436da</font></b></div><div><b><font color="#E30000">com.atguigu.intercepter.MyIntercepter1@5183c342</font></b></div><div><b><font color="#E30000">com.atguigu.intercepter.MyIntercepter@55bc5daa</font></b></div><div>                        if (mappedHandler == null ||  mappedHandler.getHandler() == null) {</div><div>                              noHandlerFound(processedRequest,  response);</div><div>                              return;</div><div>                        }</div><div>                        // Determine handler adapter for the current  request.</div><div>                        HandlerAdapter ha =  getHandlerAdapter(mappedHandler.getHandler());</div><div>                        // Process last-modified header, if supported by  the handler.</div><div>                        String method = request.getMethod();</div><div>                        boolean isGet = &quot;GET&quot;.equals(method);</div><div>                        if (isGet || &quot;HEAD&quot;.equals(method)) {</div><div>                              long lastModified =  ha.getLastModified(request, mappedHandler.getHandler());</div><div>                              if (logger.isDebugEnabled()) {</div><div>                                    String requestUri =  urlPathHelper.getRequestUri(request);</div><div>                                    logger.debug(&quot;Last-Modified value  for [&quot; + requestUri + &quot;] is: &quot; + lastModified);</div><div>                              }</div><div>                              if (new ServletWebRequest(request,  response).checkNotModified(lastModified) &amp;&amp; isGet) {</div><div>                                    return;</div><div>                              }</div><div>                        }</div><div><b style="color: rgb(255, 0, 0);">//拦截器执行,如果一个拦截器返回false ,该方法返回</b><font color="#BC0058"> </font><b><font color="#E30000">return跳出方法,目标方法不会执行</font></b></div><div>                  <b><font color="#FF0000">      if  (!mappedHandler.applyPreHandle(processedRequest, response)) {</font></b></div><div>                              return;</div><div>                        }</div><div>                        try {</div><div>                              // Actually invoke the handler.</div><div><b><font color="#FF0000">//如果目标方法抛出异常,该异常则抛出去,下面applyPostHandle不执行，执行processDispatchResult(processedRequest, response, mappedHandler, mv,  dispatchException);</font></b></div><div>                              mv = ha.handle(processedRequest, response,  mappedHandler.getHandler());</div><div>                        }</div><div>                        finally {</div><div>                              if  (asyncManager.isConcurrentHandlingStarted()) {</div><div>                                    return;</div><div>                              }</div><div>                        }</div><div>                        applyDefaultViewName(request, mv);</div><div>                    <b><font style="color: rgb(255, 0, 0);">    mappedHandler.applyPostHandle(processedRequest,  response, mv);</font></b></div><div>                  }</div><div>                  catch (Exception ex) {</div><div>                        dispatchException = ex;</div><div>                  }</div><div><b><font style="color: rgb(255, 0, 0);"><span>    </span><span>    </span><span>    </span><span>    </span><span>  </span>//如果页面渲染有异常,则跳到triggerAfterCompletion</font></b></div><div>            <b><font color="#FF4635">      processDispatchResult(processedRequest, response,  mappedHandler, mv, dispatchException);</font></b></div><div>            }</div><div>            catch (Exception ex) {</div><div>                  <b><font color="#FF0000">triggerAfterCompletion</font></b>(processedRequest, response,  mappedHandler, ex);</div><div>            }</div><div>            catch (Error err) {</div><div>                  triggerAfterCompletionWithError(processedRequest,  response, mappedHandler, err);</div><div>            }</div><div>            finally {</div><div>                  if (asyncManager.isConcurrentHandlingStarted()) {</div><div>                        // Instead of postHandle and afterCompletion</div><div>                        mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest,  response);</div><div>                        return;</div><div>                  }</div><div>                  // Clean up any resources used by a multipart request.</div><div>                  if (multipartRequestParsed) {</div><div>                        cleanupMultipart(processedRequest);</div><div>                  }</div><div>            }</div><div>      }</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>      boolean <b><font color="#FF4635">applyPreHandle</font></b>(HttpServletRequest request,  HttpServletResponse response) throws Exception {</div><div>            if (getInterceptors() != null) {</div><div>                  for (int i = 0; i &lt; getInterceptors().length; i++) {</div><div>                        HandlerInterceptor interceptor =  getInterceptors()[i];</div><div>                        if (!interceptor.<b><font color="#FF4635">preHandle</font></b>(request, response,  this.handler)) {</div><div><b><font color="#FF4635"><span>    </span><span>    </span><span>    </span><span>    如果返回的是false,</span>执行aftercompletion</font></b></div><div>                              triggerAfterCompletion(request, response,  null);</div><div>                              return false;</div><div>                        }</div><div><b><font color="#FF0000"><span>    </span><span>    </span><span>    </span><span>    </span>//下一个拦截器,记录已经执的拦截器</font></b></div><div>                        this.interceptorIndex = i;</div><div>                  }</div><div>            }</div><div>            return true;</div><div>      }</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span>    </span>void <b><font color="#FF0000">applyPostHandle</font></b>(HttpServletRequest request, HttpServletResponse  response, ModelAndView mv) throws Exception {</div><div>            if (getInterceptors() == null) {</div><div>                  return;</div><div>            }</div><div>     <b><font color="#FF0000">       for (int i = getInterceptors().length - 1; i &gt;= 0; i--) {</font></b></div><div>                  HandlerInterceptor interceptor = getInterceptors()[i];</div><div>                  interceptor.<b><font color="#FF0000">postHandle</font></b>(request, response,  this.handler, mv);</div><div>            }</div><div>      }</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>private void <b><font color="#FF0000">processDispatchResult</font></b>(HttpServletRequest request,  HttpServletResponse response,</div><div>                  HandlerExecutionChain mappedHandler, ModelAndView mv,  Exception exception) throws Exception {</div><div>            boolean errorView = false;</div><div>            if (exception != null) {</div><div>                  if (exception instanceof  ModelAndViewDefiningException) {</div><div>                        logger.debug(&quot;ModelAndViewDefiningException  encountered&quot;, exception);</div><div>                        mv = ((ModelAndViewDefiningException)  exception).getModelAndView();</div><div>                  }</div><div>                  else {</div><div>                        Object handler = (mappedHandler != null ?  mappedHandler.getHandler() : null);</div><div>                        mv = processHandlerException(request, response,  handler, exception);</div><div>                        errorView = (mv != null);</div><div>                  }</div><div>            }</div><div>            // Did the handler return a view to render?</div><div>            if (mv != null &amp;&amp; !mv.wasCleared()) {</div><div><b><font color="#FF0000">//如果页面渲染有异常</font></b></div><div>               <b><font color="#FF0000">   render(mv, request, response);</font></b></div><div>                  if (errorView) {</div><div>                        WebUtils.clearErrorRequestAttributes(request);</div><div>                  }</div><div>            }</div><div>            else {</div><div>                  if (logger.isDebugEnabled()) {</div><div>                        logger.debug(&quot;Null ModelAndView returned to  DispatcherServlet with name '&quot; + getServletName() +</div><div>                                    &quot;': assuming HandlerAdapter  completed request handling&quot;);</div><div>                  }</div><div>            }</div><div>            if  (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {</div><div>                  // Concurrent handling started during a forward</div><div>                  return;</div><div>            }</div><div>            if (mappedHandler != null) {</div><div>                <b><font color="#FF0000">  mappedHandler.triggerAfterCompletion(request,  response, null);</font></b></div><div>            }</div><div>      }</div><div><br/></div><div><br/></div><div><br/></div><div>void <b><font color="#FF4635">triggerAfterCompletion</font></b>(HttpServletRequest request,  HttpServletResponse response, Exception ex)</div><div>                  throws Exception {</div><div>            if (getInterceptors() == null) {</div><div>                  return;</div><div>            }</div><div><b><font color="#FF0000">            for (int i = this.interceptorIndex; i &gt;= 0; i--) {</font></b></div><div>                  HandlerInterceptor interceptor = getInterceptors()[i];</div><div>                  try {</div><div>                        interceptor.<b><font color="#FF0000">afterCompletion</font></b>(request, response,  this.handler, ex);</div><div>                  }</div><div>                  catch (Throwable ex2) {</div><div>                        logger.error(&quot;HandlerInterceptor.afterCompletion  threw exception&quot;, ex2);</div><div>                  }</div><div>            }</div><div>      }</div></div><div><br/></div></span>
</div></body></html> 